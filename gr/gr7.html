<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Stat & Graph Studio — Apple-level (1 arquivo)</title>
  <meta name="color-scheme" content="dark light"/>
  <style>
    :root{
      --bg:#0b0f14; --bg2:#0e1420;
      --panel:rgba(255,255,255,.07);
      --panel2:rgba(255,255,255,.035);
      --stroke:rgba(255,255,255,.12);
      --stroke2:rgba(255,255,255,.18);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --muted2:rgba(255,255,255,.45);
      --shadow:0 22px 70px rgba(0,0,0,.55);
      --shadow2:0 10px 30px rgba(0,0,0,.35);
      --radius:18px; --radius2:14px;
      --primary:108 168 255;
      --success:118 242 180;
      --danger:255 92 92;
      --warn:255 204 102;

      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,"Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans","Liberation Sans", sans-serif;
      --focus:0 0 0 4px rgba(108,168,255,.25);
    }
    [data-theme="light"]{
      --bg:#f6f7fb; --bg2:#eef2f7;
      --panel:rgba(255,255,255,.95);
      --panel2:rgba(255,255,255,.75);
      --stroke:rgba(14,18,28,.12);
      --stroke2:rgba(14,18,28,.18);
      --text:rgba(14,18,28,.92);
      --muted:rgba(14,18,28,.62);
      --muted2:rgba(14,18,28,.45);
      --shadow:0 22px 70px rgba(2,6,23,.12);
      --shadow2:0 10px 30px rgba(2,6,23,.10);
      --focus:0 0 0 4px rgba(33,112,255,.18);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 0%, rgba(108,168,255,.28) 0%, rgba(108,168,255,0) 55%),
        radial-gradient(900px 600px at 90% 20%, rgba(118,242,180,.18) 0%, rgba(118,242,180,0) 60%),
        linear-gradient(180deg, var(--bg2), var(--bg));
      overflow-x:hidden;
    }

    .topbar{
      position:sticky; top:0; z-index:60;
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      background: linear-gradient(180deg, rgba(0,0,0,.18), rgba(0,0,0,0));
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    [data-theme="light"] .topbar{
      background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.35));
      border-bottom:1px solid rgba(14,18,28,.08);
    }
    .topbar-inner{
      max-width: 1480px;
      margin:0 auto;
      padding: 14px 16px;
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }

    .brand{ display:flex; align-items:center; gap:10px; }
    .logo{
      width:34px; height:34px; border-radius:12px;
      background:
        radial-gradient(16px 16px at 30% 30%, rgba(255,255,255,.35), rgba(255,255,255,0)),
        linear-gradient(180deg, rgba(108,168,255,.95), rgba(108,168,255,.25));
      box-shadow: 0 14px 40px rgba(108,168,255,.22);
      border:1px solid rgba(255,255,255,.18);
    }
    [data-theme="light"] .logo{
      border:1px solid rgba(14,18,28,.10);
      box-shadow: 0 14px 40px rgba(33,112,255,.15);
    }
    .brand h1{font-size:14px; margin:0; letter-spacing:.2px;}
    .brand p{margin:0; font-size:12px; color:var(--muted); line-height:1.25;}

    .actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end;}

    .wrap{
      max-width: 1480px;
      margin: 0 auto;
      padding: 14px 16px 26px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 1160px){ .wrap{grid-template-columns:1fr} }

    .card{
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow2);
      overflow:hidden;
      position:relative;
    }
    .card::before{
      content:"";
      position:absolute; inset:-1px;
      background: radial-gradient(800px 260px at 10% 0%, rgba(108,168,255,.10), transparent 60%);
      pointer-events:none;
    }
    [data-theme="light"] .card::before{
      background: radial-gradient(800px 260px at 10% 0%, rgba(33,112,255,.10), transparent 60%);
    }

    .card-hd{
      padding: 12px 12px 10px;
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.04);
    }
    [data-theme="light"] .card-hd{ background: rgba(255,255,255,.55); }
    .card-title{ display:flex; align-items:center; gap:10px; min-width:240px; }
    .badge{
      font-size:12px; color:var(--muted);
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      white-space:nowrap;
    }
    [data-theme="light"] .badge{ background: rgba(255,255,255,.55); }

    .card-bd{ padding: 12px; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row + .row{ margin-top:10px; }
    .sp{ flex:1; }

    .field{ display:flex; flex-direction:column; gap:6px; flex:1; min-width:220px;}
    .label{ font-size:12px; color:var(--muted); }
    .hint{ font-size:12px; color:var(--muted2); line-height:1.35; }

    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      color: var(--text);
      font-size: 13px;
      outline: none;
      transition: .16s border-color, .16s transform, .16s background;
    }
    [data-theme="light"] input[type="text"], [data-theme="light"] input[type="number"],
    [data-theme="light"] select, [data-theme="light"] textarea{ background: rgba(255,255,255,.85); }
    input:focus, select:focus, textarea:focus{ border-color: rgba(var(--primary), .55); box-shadow: var(--focus); }
    textarea{ min-height: 78px; resize: vertical; font-family: var(--mono); }

    .btn{
      display:inline-flex; align-items:center; justify-content:center; gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.12);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      user-select:none;
      transition: .16s transform, .16s background, .16s border-color, .16s box-shadow;
      white-space:nowrap;
    }
    [data-theme="light"] .btn{ background: rgba(255,255,255,.85); }
    .btn:hover{ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.06); }
    [data-theme="light"] .btn:hover{ background: rgba(255,255,255,1); }
    .btn:active{ transform: translateY(0px); }
    .btn:focus{ outline:none; box-shadow: var(--focus); border-color: rgba(var(--primary), .55); }
    .btn.primary{ border-color: rgba(var(--primary), .45); background: rgba(var(--primary), .18); }
    .btn.success{ border-color: rgba(118,242,180,.35); background: rgba(118,242,180,.14); }
    .btn.danger{ border-color: rgba(255,92,92,.35); background: rgba(255,92,92,.12); }
    .btn.warn{ border-color: rgba(255,204,102,.35); background: rgba(255,204,102,.12); }
    .btn.ghost{ background: transparent; }
    .btn.small{ padding: 8px 10px; border-radius: 12px; font-size:12px; }

    .seg{
      display:flex; gap:8px; flex-wrap:wrap;
      align-items:center;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.08);
    }
    [data-theme="light"] .seg{ background: rgba(255,255,255,.65); }

    .check{
      display:flex; gap:8px; align-items:center;
      font-size: 12px; color: var(--muted);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      user-select:none;
    }
    [data-theme="light"] .check{ background: rgba(255,255,255,.80); }

    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 9px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.12);
      color: var(--text);
    }
    [data-theme="light"] .kbd{ background: rgba(255,255,255,.9); }

    .tabs{
      display:flex; flex-wrap:wrap; gap:8px;
      padding: 10px;
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.08);
    }
    [data-theme="light"] .tabs{ background: rgba(255,255,255,.65); }
    .tab{
      display:flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      cursor:pointer;
      user-select:none;
      font-size:12px;
      color: var(--muted);
      transition:.15s transform, .15s background, .15s border-color;
    }
    [data-theme="light"] .tab{ background: rgba(255,255,255,.85); }
    .tab:hover{ transform: translateY(-1px); border-color: var(--stroke2); }
    .tab.on{
      color: var(--text);
      border-color: rgba(var(--primary), .45);
      background: rgba(var(--primary), .16);
    }
    .tab .x{
      border:none; background: transparent; color: var(--muted);
      font-size:16px; line-height:1; cursor:pointer;
      padding: 0 4px; border-radius: 10px;
    }
    .tab .x:hover{ background: rgba(255,255,255,.08); color: var(--text); }
    [data-theme="light"] .tab .x:hover{ background: rgba(14,18,28,.06); }

    .table-wrap{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      overflow:hidden;
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .table-wrap{ background: rgba(255,255,255,.78); }
    table{ width:100%; border-collapse: separate; border-spacing:0; }
    thead th{
      text-align:left; font-size:12px; color: var(--muted);
      padding: 10px 12px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.05);
      white-space:nowrap;
    }
    [data-theme="light"] thead th{ background: rgba(255,255,255,.9); }
    tbody td{ padding:0; border-bottom:1px solid rgba(255,255,255,.06); }
    [data-theme="light"] tbody td{ border-bottom:1px solid rgba(14,18,28,.07); }
    tbody tr:last-child td{ border-bottom:none; }
    input.cell{
      width:100%;
      border:none; outline:none;
      padding: 11px 12px;
      font-size:13px;
      color: var(--text);
      background: transparent;
    }
    input.cell::placeholder{ color: var(--muted2); }
    td.action{ width: 74px; text-align:center; }

    .canvas-wrap{ padding: 12px; }
    canvas{
      width:100%;
      height: 640px;
      display:block;
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      cursor: crosshair;
      touch-action: none;
    }
    [data-theme="light"] canvas{ background: rgba(255,255,255,.92); }

    .legend{ display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; }
    .legend .item{
      display:flex; align-items:center; gap:10px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      color: var(--muted);
      cursor:pointer;
      user-select:none;
      transition:.15s transform, .15s background, .15s border-color;
    }
    [data-theme="light"] .legend .item{ background: rgba(255,255,255,.85); }
    .legend .item:hover{ transform: translateY(-1px); border-color: var(--stroke2); }
    .legend .item.off{ opacity:.45; filter:saturate(.65); }
    .dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }

    .mini{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.08);
      padding: 10px;
    }
    [data-theme="light"] .mini{ background: rgba(255,255,255,.72); }

    .stats-grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width:680px){ .stats-grid{ grid-template-columns:1fr; } }
    .stat{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.03);
      padding: 10px;
    }
    [data-theme="light"] .stat{ background: rgba(255,255,255,.92); }
    .stat .head{ display:flex; align-items:center; gap:10px; margin-bottom:8px; color:var(--muted); font-size:12px; }
    .stat .kvline{ display:flex; justify-content:space-between; gap:12px; color:var(--muted); font-size:12px; padding:2px 0; }
    .stat .kvline .v{ font-family: var(--mono); color: var(--text); }

    .tooltip{
      position: fixed; z-index: 90;
      pointer-events:none;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--stroke);
      background: rgba(10,14,22,.92);
      color: rgba(255,255,255,.92);
      box-shadow: var(--shadow2);
      display:none;
      max-width: 420px;
    }
    [data-theme="light"] .tooltip{
      background: rgba(255,255,255,.96);
      color: rgba(14,18,28,.92);
    }
    .tooltip .t{ font-weight: 650; margin-bottom: 8px; display:flex; align-items:center; gap:10px;}
    .tooltip .kv{ display:flex; justify-content:space-between; gap:12px; font-size:12px; color: rgba(255,255,255,.78); }
    [data-theme="light"] .tooltip .kv{ color: rgba(14,18,28,.72); }
    .tooltip .v{ font-family: var(--mono); color: inherit; }

    .toasts{
      position: fixed;
      right: 14px;
      bottom: 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
      z-index: 110;
      width: min(440px, calc(100vw - 28px));
    }
    .toast{
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.05));
      box-shadow: var(--shadow2);
      padding: 10px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      animation: pop .18s ease-out;
    }
    [data-theme="light"] .toast{
      background: linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.82));
    }
    @keyframes pop{ from{ transform: translateY(6px); opacity:0; } to{ transform: translateY(0); opacity:1; } }
    .toast .title{ font-size:13px; font-weight:650; margin:0; }
    .toast .msg{ margin:2px 0 0; font-size:12px; color: var(--muted); line-height:1.35; }
    .toast .icon{
      width: 26px; height:26px; border-radius: 10px;
      display:flex; align-items:center; justify-content:center;
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.10);
      flex:none;
    }
    [data-theme="light"] .toast .icon{ background: rgba(255,255,255,.92); }
    .toast.ok .icon{ border-color: rgba(118,242,180,.35); }
    .toast.err .icon{ border-color: rgba(255,92,92,.35); }
    .toast .x{
      margin-left:auto;
      border:none;
      background: transparent;
      color: var(--muted);
      cursor:pointer;
      font-size: 18px;
      line-height: 1;
      padding: 2px 6px;
      border-radius: 10px;
    }
    .toast .x:hover{ background: rgba(255,255,255,.08); color: var(--text); }
    [data-theme="light"] .toast .x:hover{ background: rgba(14,18,28,.06); }

    .overlay{
      position:fixed; inset:0; z-index:140;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:none;
      align-items:flex-start;
      justify-content:center;
      padding: 10vh 14px 14px;
    }
    [data-theme="light"] .overlay{ background: rgba(14,18,28,.20); }
    .palette{
      width:min(760px, 100%);
      border-radius: 18px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .palette-hd{ padding: 10px; border-bottom:1px solid var(--stroke); display:flex; gap:10px; align-items:center; }
    .palette-hd input{ padding: 12px 12px; border-radius: 14px; font-size: 13px; background: rgba(0,0,0,.10); }
    .palette-list{ max-height: 420px; overflow:auto; }
    .cmd{
      display:flex; justify-content:space-between; align-items:center;
      padding: 12px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      cursor:pointer;
    }
    [data-theme="light"] .cmd{ border-bottom:1px solid rgba(14,18,28,.06); }
    .cmd:hover{ background: rgba(255,255,255,.06); }
    [data-theme="light"] .cmd:hover{ background: rgba(14,18,28,.04); }
    .cmd .left{ display:flex; flex-direction:column; gap:2px; }
    .cmd .name{ font-weight:650; font-size:13px; }
    .cmd .desc{ font-size:12px; color: var(--muted); }
    .cmd .right{ display:flex; gap:6px; align-items:center; color: var(--muted); }
    .pill{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.10);
    }
    [data-theme="light"] .pill{ background: rgba(255,255,255,.88); }

    body.presentation .topbar,
    body.presentation .toasts,
    body.presentation .overlay,
    body.presentation .tooltip,
    body.presentation #leftPane { display:none !important; }
    body.presentation .wrap{
      grid-template-columns: 1fr !important;
      max-width: 100% !important;
      padding: 10px !important;
    }
    body.presentation canvas{ height: calc(100vh - 24px) !important; }

    @media print{
      body{ background:white !important; color:black !important; }
      .topbar, .toasts, .tooltip, .overlay{ display:none !important; }
      .wrap{ grid-template-columns: 1fr !important; max-width: 100% !important; }
      canvas{ border: 1px solid #ccc !important; background: white !important; }
      .card{ box-shadow:none !important; border:1px solid #ddd !important; }
      .card::before{ display:none !important; }
      .badge, .btn{ display:none !important; }
      .legend .item{ border:1px solid #ddd !important; background:white !important; }
    }
    @media (prefers-reduced-motion: reduce){
      *{ animation:none !important; transition:none !important; scroll-behavior:auto !important; }
    }
  </style>
</head>

<body data-theme="dark">
  <div class="topbar" role="banner">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Stat & Graph Studio</h1>
          <p>Apple-level • Estatística + Gráficos • <span class="kbd">Ctrl</span>+<span class="kbd">K</span> comandos</p>
        </div>
      </div>

      <div class="actions" role="toolbar" aria-label="Ações">
        <button class="btn small ghost" id="btnTheme">Tema</button>
        <button class="btn small" id="btnCmd">Comandos</button>
        <button class="btn small" id="btnPresent">Apresentação</button>

        <button class="btn small" id="btnSaveJSON">Salvar Projeto</button>
        <input id="fileJSON" type="file" accept=".json,application/json" hidden>
        <button class="btn small" id="btnLoadJSON">Carregar</button>

        <input id="fileImport" type="file" accept=".csv,.tsv,.txt,.json,application/json,text/csv,text/tab-separated-values,text/plain" hidden>
        <button class="btn small" id="btnImport">Importar CSV/TSV/JSON</button>

        <button class="btn small" id="btnSVG">Exportar SVG</button>
        <button class="btn small" id="btnPNG">Exportar PNG</button>
        <button class="btn small warn" id="btnReport">Relatório (PDF/Print)</button>
      </div>
    </div>
  </div>

  <main class="wrap" role="main">
    <!-- LEFT -->
    <section class="card" id="leftPane" aria-label="Dados, análises e configurações">
      <div class="card-hd">
        <div class="card-title">
          <strong>Projeto</strong>
          <span class="badge">Abas • Planilha • Import • Colar • Estatística • Multi-gráficos</span>
        </div>
        <div class="row" style="margin:0">
          <button class="btn" id="btnNewTab">+ Aba</button>
          <button class="btn" id="btnAddRow">+ Linha</button>
          <button class="btn" id="btnAddSeries">+ Série</button>
          <button class="btn success" id="btnExample">Exemplo</button>
          <button class="btn danger" id="btnClear">Limpar</button>
        </div>
      </div>

      <div class="card-bd">
        <div class="row">
          <div class="field">
            <div class="label">Abas do projeto</div>
            <div class="tabs" id="tabs"></div>
            <div class="hint">Cada aba tem dados/configurações independentes. Salva automaticamente (local).</div>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="label">Título</div>
            <input id="title" type="text" value="Análise: Y por X"/>
          </div>
          <div class="field" style="min-width:210px">
            <div class="label">Tipo de X</div>
            <select id="xMode">
              <option value="auto">Auto</option>
              <option value="numeric">Numérico</option>
              <option value="category">Texto (categorias)</option>
              <option value="datetime">Data/Hora</option>
            </select>
          </div>
          <div class="field" style="min-width:200px">
            <div class="label">Ordenar X</div>
            <select id="sortX">
              <option value="auto">Auto</option>
              <option value="no">Não</option>
              <option value="yes">Sim</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="label">Eixo X</div>
            <input id="xLabel" type="text" value="X"/>
          </div>
          <div class="field">
            <div class="label">Eixo Y</div>
            <input id="yLabel" type="text" value="Y"/>
          </div>
        </div>

        <div class="seg" aria-label="Controles principais">
          <div class="field" style="min-width:220px; flex:0">
            <div class="label">Gráfico</div>
            <select id="chartType">
              <option value="line">Linha + Pontos</option>
              <option value="scatter">Dispersão</option>
              <option value="hist">Histograma (Y selecionado)</option>
              <option value="box">Boxplot (Y selecionado)</option>
              <option value="ecdf">ECDF (Y selecionado)</option>
            </select>
          </div>

          <div class="field" style="min-width:220px; flex:0">
            <div class="label">Série Y (para hist/box/ecdf)</div>
            <select id="focusY"></select>
          </div>

          <label class="check"><input id="chkLogY" type="checkbox"/> Y em log10</label>
          <label class="check"><input id="chkMA" type="checkbox"/> Suavizar (média móvel)</label>

          <div class="field" style="min-width:140px; flex:0">
            <div class="label">Janela</div>
            <input id="maWindow" type="number" min="2" max="99" step="1" value="5"/>
          </div>

          <span class="sp"></span>
          <button class="btn primary" id="btnAnalyze">Analisar + Gráficos</button>
          <button class="btn" id="btnReset">Reset zoom/pan</button>
        </div>

        <div class="hint" style="margin-top:10px">
          Colar dados do Excel/Sheets: selecione o canto superior esquerdo e cole (<span class="kbd">Ctrl</span>+<span class="kbd">V</span>).<br/>
          Atalhos: <span class="kbd">Ctrl</span>+<span class="kbd">Enter</span> analisar • <span class="kbd">Ctrl</span>+<span class="kbd">K</span> comandos • Pinch (celular) zoom • Arrastar pan.
        </div>

        <div style="height:12px"></div>

        <div class="table-wrap">
          <table id="grid" aria-label="Tabela de dados (X e Ys)">
            <thead><tr id="theadRow"></tr></thead>
            <tbody id="tbody"></tbody>
          </table>
        </div>

        <div style="height:12px"></div>

        <section class="mini" aria-label="Estatística (por série)">
          <div class="row" style="justify-content:space-between">
            <strong style="font-size:13px">Estatística completa</strong>
            <span class="hint">média, mediana, percentis, dispersão, forma, correlação</span>
          </div>
          <div id="statsPanel" class="stats-grid" style="margin-top:10px"></div>
        </section>

        <div style="height:12px"></div>

        <section class="mini" aria-label="Séries e estilos">
          <div class="row" style="justify-content:space-between">
            <strong style="font-size:13px">Séries (estilo + visibilidade)</strong>
            <span class="hint">Clique na legenda do gráfico para ocultar/mostrar.</span>
          </div>
          <div id="seriesPanel" class="hint" style="margin-top:10px">Clique em “Analisar + Gráficos”.</div>
        </section>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card" aria-label="Gráficos">
      <div class="card-hd">
        <div class="card-title">
          <strong>Gráficos</strong>
          <span class="badge">Canvas • Tooltip • Zoom/Pan • Export PNG/SVG</span>
        </div>
        <div class="row" style="margin:0">
          <span class="badge">Atalho: <span class="kbd">Ctrl</span>+<span class="kbd">Enter</span></span>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="cv"></canvas>
        <div id="legend" class="legend" aria-label="Legenda"></div>
      </div>
    </section>
  </main>

  <div id="tooltip" class="tooltip" role="status" aria-live="polite"></div>
  <div class="toasts" id="toasts" aria-live="polite" aria-atomic="true"></div>

  <!-- Command Palette -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-label="Comandos">
    <div class="palette">
      <div class="palette-hd">
        <input id="cmdSearch" type="text" placeholder="Digite um comando… (ex: importar, histograma, tema, apresentação)"/>
        <span class="pill">Esc</span>
      </div>
      <div class="palette-list" id="cmdList"></div>
    </div>
  </div>

<script>
/* ============================================================
   Stat & Graph Studio — 1 arquivo, profissional (Apple/Microsoft)
   Inclui tudo que conversamos:
   - Planilha (X + múltiplos Y) com input manual
   - Colar do Excel/Sheets (TSV)
   - Importar CSV/TSV/JSON
   - Abas (vários projetos no mesmo arquivo)
   - Estatística completa (média, percentis, dispersão etc)
   - Gráficos: Linha+Pontos, Scatter, Hist, Box, ECDF
   - Zoom/Pan (mouse + touch/pinch)
   - Tooltip inteligente (ponto mais próximo)
   - Export PNG + Export SVG
   - Salvar/Carregar Projeto (JSON)
   - Autosave local (localStorage)
   - Modo Apresentação (tela cheia / clean)
   - Command palette (Ctrl+K)
============================================================ */

const palette = [
  "rgba(108,168,255,1)",
  "rgba(118,242,180,1)",
  "rgba(255,204,102,1)",
  "rgba(255,92,92,1)",
  "rgba(186,143,255,1)",
  "rgba(94,234,212,1)",
  "rgba(255,120,200,1)",
  "rgba(180,255,120,1)",
];

const $ = (s)=>document.querySelector(s);
const $$ = (s)=>[...document.querySelectorAll(s)];
const tbody = $("#tbody");
const theadRow = $("#theadRow");
const legendBox = $("#legend");
const seriesPanel = $("#seriesPanel");
const statsPanel = $("#statsPanel");
const tabsBox = $("#tabs");
const tooltip = $("#tooltip");
const toasts = $("#toasts");
const cv = $("#cv");
const ctx = cv.getContext("2d");

const overlay = $("#overlay");
const cmdSearch = $("#cmdSearch");
const cmdList = $("#cmdList");

const LS_KEY = "stat_graph_studio_autosave_v2";

function toast(type, title, msg){
  const el = document.createElement("div");
  el.className = `toast ${type}`;
  const icon = type==="ok" ? "✓" : type==="err" ? "!" : "i";
  el.innerHTML = `
    <div class="icon" aria-hidden="true">${icon}</div>
    <div>
      <p class="title">${title}</p>
      <p class="msg">${msg}</p>
    </div>
    <button class="x" aria-label="Fechar">×</button>
  `;
  el.querySelector(".x").onclick = ()=> el.remove();
  toasts.appendChild(el);
  setTimeout(()=>{ if (el.isConnected) el.remove(); }, 5200);
}
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function uid(){ return Math.random().toString(16).slice(2) + "-" + Date.now().toString(16); }

/* ---------- Parse num/date ---------- */
function parseNumberBR(v){
  if (v == null) return NaN;
  v = String(v).trim();
  if (!v) return NaN;
  v = v.replace(/\s+/g,"");
  if (v.includes(",")) v = v.replace(/\./g,"").replace(",",".");
  const n = Number(v);
  return Number.isFinite(n) ? n : NaN;
}
function fmt(n, d=6){
  if (!Number.isFinite(n)) return "NaN";
  const s = n.toFixed(d);
  return s.replace(/\.?0+$/,"");
}
function parseDateTimeToMs(s){
  if (s == null) return NaN;
  const v = String(s).trim();
  if (!v) return NaN;

  let iso = v.replace(" ", "T");
  let d = new Date(iso);
  if (!isNaN(d.getTime())) return d.getTime();

  const m = v.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m){
    const dd = Number(m[1]), mm = Number(m[2]), yyyy = Number(m[3]);
    const hh = Number(m[4] || 0), mi = Number(m[5] || 0), ss = Number(m[6] || 0);
    const dt = new Date(yyyy, mm-1, dd, hh, mi, ss);
    return dt.getTime();
  }
  return NaN;
}
function formatMsToLabel(ms){
  const d = new Date(ms);
  const dd = String(d.getDate()).padStart(2,"0");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const yyyy = d.getFullYear();
  const hh = String(d.getHours()).padStart(2,"0");
  const mi = String(d.getMinutes()).padStart(2,"0");
  if (hh !== "00" || mi !== "00") return `${dd}/${mm}/${yyyy} ${hh}:${mi}`;
  return `${dd}/${mm}/${yyyy}`;
}

/* ---------- Model ---------- */
function defaultTab(){
  return {
    id: uid(),
    name: "Aba 1",
    seriesCount: 1,
    styles: [{ name:"Y1", color: palette[0], width:2.2, point:4.3, dashed:false }],
    visible: [true],
    data: Array.from({length:14}, ()=>["",""]),
    view: { zoomX:1, zoomY:1, panX:0, panY:0 },
    meta: {
      title: "Análise: Y por X",
      xLabel: "X",
      yLabel: "Y",
      xMode: "auto",
      sortX: "auto",
      chartType: "line",
      focusY: 0,
      logY: false,
      ma: false,
      maWindow: 5
    },
    analysis: null
  };
}
const state = {
  tabs: [defaultTab()],
  activeId: null,
  theme: "dark",
  presentation: false,
};

function activeTab(){
  if (!state.activeId) state.activeId = state.tabs[0].id;
  return state.tabs.find(t=>t.id===state.activeId) || state.tabs[0];
}
function ensureStyles(tab){
  while(tab.styles.length < tab.seriesCount){
    const i = tab.styles.length;
    tab.styles.push({ name: "Y"+(i+1), color: palette[i % palette.length], width:2.2, point:4.3, dashed:false });
  }
  while(tab.visible.length < tab.seriesCount) tab.visible.push(true);
}

/* ---------- Tabs UI ---------- */
function renderTabs(){
  tabsBox.innerHTML = "";
  state.tabs.forEach((t)=>{
    const el = document.createElement("div");
    el.className = "tab" + (t.id===activeTab().id ? " on" : "");
    el.innerHTML = `<span>${escapeHtml(t.name)}</span>${state.tabs.length>1 ? `<button class="x" title="Fechar">×</button>` : ""}`;
    el.addEventListener("click", (e)=>{
      if (e.target.classList.contains("x")) return;
      state.activeId = t.id;
      loadTabToUI();
      autosave();
    });
    const x = el.querySelector(".x");
    if (x){
      x.addEventListener("click",(e)=>{
        e.stopPropagation();
        closeTab(t.id);
      });
    }
    tabsBox.appendChild(el);
  });
}
function newTab(){
  const t = defaultTab();
  t.name = `Aba ${state.tabs.length+1}`;
  state.tabs.push(t);
  state.activeId = t.id;
  loadTabToUI();
  autosave();
  toast("ok","Aba criada", t.name);
}
function closeTab(id){
  if (state.tabs.length<=1) return;
  const idx = state.tabs.findIndex(t=>t.id===id);
  if (idx<0) return;
  const name = state.tabs[idx].name;
  const wasActive = activeTab().id===id;
  state.tabs.splice(idx,1);
  if (wasActive){
    state.activeId = state.tabs[Math.max(0, idx-1)].id;
  }
  loadTabToUI();
  autosave();
  toast("ok","Aba removida", name);
}

/* ---------- Table (grid) ---------- */
function rebuildHeader(tab){
  theadRow.innerHTML = "";
  const thX = document.createElement("th");
  thX.textContent="X";
  thX.style.width="30%";
  theadRow.appendChild(thX);

  for(let s=1;s<=tab.seriesCount;s++){
    const th = document.createElement("th");
    th.textContent="Y"+s;
    theadRow.appendChild(th);
  }
  const thRem = document.createElement("th");
  thRem.textContent="Rem";
  thRem.style.width="74px";
  thRem.style.textAlign="center";
  theadRow.appendChild(thRem);
}
function addRowUI(tab, values){
  const tr = document.createElement("tr");

  const tdX = document.createElement("td");
  const inX = document.createElement("input");
  inX.className="cell";
  inX.placeholder="Ex: 1 ou 12/01/2026 14:30";
  inX.value = values?.[0] ?? "";
  tdX.appendChild(inX);
  tr.appendChild(tdX);

  for(let s=1;s<=tab.seriesCount;s++){
    const tdY = document.createElement("td");
    const inY = document.createElement("input");
    inY.className="cell";
    inY.placeholder="Ex: 10,5";
    inY.value = values?.[s] ?? "";
    tdY.appendChild(inY);
    tr.appendChild(tdY);
  }

  const tdA = document.createElement("td");
  tdA.className="action";
  const btn = document.createElement("button");
  btn.className="btn small danger";
  btn.textContent="×";
  btn.title="Remover linha";
  btn.onclick = ()=>{
    tr.remove();
    syncUIToTab();
    autosave();
  };
  tdA.appendChild(btn);
  tr.appendChild(tdA);

  tbody.appendChild(tr);
}
function rebuildGridFromTab(tab){
  tbody.innerHTML = "";
  for(let r=0;r<tab.data.length;r++) addRowUI(tab, tab.data[r]);
}
function syncUIToTab(){
  const tab = activeTab();
  const rows = [...tbody.querySelectorAll("tr")];
  tab.data = rows.map(tr => [...tr.querySelectorAll("input")].map(i => i.value.trim()));
  tab.meta.title = $("#title").value;
  tab.meta.xLabel = $("#xLabel").value;
  tab.meta.yLabel = $("#yLabel").value;
  tab.meta.xMode = $("#xMode").value;
  tab.meta.sortX = $("#sortX").value;
  tab.meta.chartType = $("#chartType").value;
  tab.meta.focusY = Number($("#focusY").value||0);
  tab.meta.logY = $("#chkLogY").checked;
  tab.meta.ma = $("#chkMA").checked;
  tab.meta.maWindow = Number($("#maWindow").value||5);
}
function addSeries(){
  const tab = activeTab();
  tab.seriesCount += 1;
  ensureStyles(tab);
  tab.data = tab.data.map(row=>{
    const r = row.slice();
    while(r.length < tab.seriesCount+1) r.push("");
    return r;
  });
  rebuildHeader(tab);
  rebuildGridFromTab(tab);
  rebuildFocusY(tab);
  autosave();
  toast("ok","Série adicionada",`Agora você tem ${tab.seriesCount} séries Y.`);
}
function addRow(){
  const tab = activeTab();
  tab.data.push(Array.from({length:tab.seriesCount+1}, ()=>""));
  addRowUI(tab, tab.data[tab.data.length-1]);
  autosave();
}

/* ---------- Paste from clipboard (TSV/CSV) ---------- */
function parseGridText(text){
  const t = text.replace(/\r/g,"").trimEnd();
  if (!t) return null;
  const lines = t.split("\n");
  const isTSV = lines.some(l => l.includes("\t"));
  const delim = isTSV ? "\t" : ",";
  const rows = lines.map(l => splitCsvLike(l, delim));
  return rows;
}
function splitCsvLike(line, delim){
  // simples e robusto para colar do Excel e CSV básico
  const out = [];
  let cur = "", inQ = false;
  for (let i=0;i<line.length;i++){
    const ch = line[i];
    if (ch === '"'){
      if (inQ && line[i+1] === '"'){ cur += '"'; i++; }
      else inQ = !inQ;
    } else if (!inQ && ch === delim){
      out.push(cur);
      cur = "";
    } else {
      cur += ch;
    }
  }
  out.push(cur);
  return out.map(s=>String(s).trim());
}
function pasteIntoGrid(startInput, gridRows){
  const tab = activeTab();
  const inputs = [...tbody.querySelectorAll("input.cell")];
  const idx = inputs.indexOf(startInput);
  if (idx < 0) return;

  const cols = tab.seriesCount + 1;
  const startRow = Math.floor(idx / cols);
  const startCol = idx % cols;

  // ensure enough rows
  const neededRows = startRow + gridRows.length;
  while (tab.data.length < neededRows){
    tab.data.push(Array.from({length: cols}, ()=>""));
  }

  for (let r=0;r<gridRows.length;r++){
    const row = gridRows[r];
    for (let c=0;c<row.length;c++){
      const rr = startRow + r;
      const cc = startCol + c;
      if (cc >= cols) continue;
      tab.data[rr][cc] = row[c] ?? "";
    }
  }

  rebuildGridFromTab(tab);
  autosave();
  toast("ok","Colagem aplicada","Dados colados na planilha.");
}

/* ---------- Import/Export ---------- */
function download(name, text, mime="text/plain"){
  const blob = new Blob([text], {type:mime});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}
function exportProjectJSON(){
  syncUIToTab();
  const payload = {
    v: 2,
    theme: state.theme,
    activeId: state.activeId,
    tabs: state.tabs
  };
  download("stat_graph_studio_project.json", JSON.stringify(payload, null, 2), "application/json");
  toast("ok","Projeto salvo","Arquivo JSON exportado.");
}
function importProjectJSON(file){
  const reader = new FileReader();
  reader.onload = ()=>{
    try{
      const obj = JSON.parse(String(reader.result||""));
      if (!obj || !Array.isArray(obj.tabs)) throw new Error("JSON inválido");
      state.theme = obj.theme==="light" ? "light" : "dark";
      state.tabs = obj.tabs.map(t=>sanitizeTab(t));
      state.activeId = obj.activeId && state.tabs.some(x=>x.id===obj.activeId) ? obj.activeId : state.tabs[0]?.id;
      applyTheme();
      loadTabToUI();
      autosave();
      toast("ok","Projeto carregado","Dados restaurados do JSON.");
    }catch(e){
      toast("err","Falha ao carregar", String(e?.message||e));
    }
  };
  reader.readAsText(file);
}
function sanitizeTab(t){
  const tab = defaultTab();
  tab.id = typeof t.id==="string" ? t.id : uid();
  tab.name = typeof t.name==="string" ? t.name : tab.name;
  tab.seriesCount = Number.isFinite(t.seriesCount) ? Math.max(1, Math.min(24, t.seriesCount)) : tab.seriesCount;
  tab.data = Array.isArray(t.data) ? t.data.map(r=>Array.isArray(r)? r.map(x=>String(x??"")) : ["",""]) : tab.data;
  tab.meta = {...tab.meta, ...(t.meta||{})};
  tab.styles = Array.isArray(t.styles) ? t.styles.map(s=>({
    name: String(s.name||"Y"),
    color: String(s.color||palette[0]),
    width: Number(s.width||2.2),
    point: Number(s.point||4.3),
    dashed: !!s.dashed
  })) : tab.styles;
  tab.visible = Array.isArray(t.visible) ? t.visible.map(Boolean) : tab.visible;
  tab.view = {...tab.view, ...(t.view||{})};
  tab.analysis = null;
  ensureStyles(tab);

  // normalize row length
  const cols = tab.seriesCount + 1;
  tab.data = tab.data.map(r=>{
    const rr = r.slice();
    while(rr.length < cols) rr.push("");
    if (rr.length > cols) rr.length = cols;
    return rr;
  });

  return tab;
}
async function importAny(file){
  const name = file.name.toLowerCase();
  const text = await file.text();
  const tab = activeTab();

  try{
    if (name.endsWith(".json")){
      const obj = JSON.parse(text);
      // Accept formats:
      // 1) {x:[...], y:[...]} OR {x:[...], ys:[[...],[...]]}
      // 2) [{x:..., y1:..., y2:...}, ...]
      if (Array.isArray(obj)){
        const keys = Object.keys(obj[0]||{});
        const xKey = keys.find(k=>k.toLowerCase()==="x") || keys[0];
        const yKeys = keys.filter(k=>k!==xKey);
        tab.seriesCount = Math.max(1, yKeys.length);
        ensureStyles(tab);
        tab.styles.forEach((s,i)=> s.name = yKeys[i] ? yKeys[i] : ("Y"+(i+1)));
        tab.data = obj.map(row=>{
          const r = [String(row[xKey]??"")];
          for (const yk of yKeys) r.push(String(row[yk]??""));
          return r;
        });
      } else if (obj && (obj.x || obj.X)){
        const x = obj.x || obj.X || [];
        const ys = obj.ys || obj.Ys || obj.y || obj.Y || [];
        if (Array.isArray(ys) && Array.isArray(ys[0])){
          tab.seriesCount = ys.length;
          ensureStyles(tab);
          tab.data = x.map((vx, i)=>{
            const r = [String(vx??"")];
            for (let s=0;s<ys.length;s++) r.push(String(ys[s]?.[i] ?? ""));
            return r;
          });
        } else {
          tab.seriesCount = 1;
          ensureStyles(tab);
          tab.data = x.map((vx,i)=>[String(vx??""), String(ys?.[i]??"")]);
        }
      } else {
        throw new Error("JSON suportado: array de objetos OU {x, y} / {x, ys}.");
      }
    } else {
      const rows = parseGridText(text);
      if (!rows) throw new Error("Arquivo vazio.");
      // if header exists, detect
      const header = rows[0];
      const body = rows.slice(1);
      const looksHeader = header && header.length>=2 && header.some(h=>/[a-zA-Z]/.test(h));
      const dataRows = looksHeader ? body : rows;

      tab.seriesCount = Math.max(1, (dataRows[0]?.length||2) - 1);
      ensureStyles(tab);

      tab.data = dataRows.map(r=>{
        const rr = r.slice();
        while(rr.length < tab.seriesCount+1) rr.push("");
        rr.length = tab.seriesCount+1;
        return rr;
      });

      if (looksHeader){
        // update series names from header
        for (let s=0;s<tab.seriesCount;s++){
          const nm = header[s+1] ? String(header[s+1]) : `Y${s+1}`;
          tab.styles[s].name = nm;
        }
      }
    }

    rebuildHeader(tab);
    rebuildGridFromTab(tab);
    rebuildFocusY(tab);
    autosave();
    toast("ok","Importação concluída","Dados carregados na planilha.");
    analyzeAndRender();
  }catch(e){
    toast("err","Falha ao importar", String(e?.message||e));
  }
}

/* ---------- Autosave ---------- */
let saveTimer = null;
function autosave(){
  clearTimeout(saveTimer);
  saveTimer = setTimeout(()=>{
    try{
      syncUIToTab();
      const payload = { v:2, theme: state.theme, activeId: state.activeId, tabs: state.tabs };
      localStorage.setItem(LS_KEY, JSON.stringify(payload));
    }catch(e){}
  }, 120);
}
function restoreAutosave(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const obj = JSON.parse(raw);
    if (!obj || !Array.isArray(obj.tabs)) return false;
    state.theme = obj.theme==="light" ? "light" : "dark";
    state.tabs = obj.tabs.map(t=>sanitizeTab(t));
    state.activeId = obj.activeId && state.tabs.some(x=>x.id===obj.activeId) ? obj.activeId : state.tabs[0]?.id;
    applyTheme();
    return true;
  }catch(e){ return false; }
}

/* ---------- Meta UI sync ---------- */
function rebuildFocusY(tab){
  const sel = $("#focusY");
  sel.innerHTML = "";
  ensureStyles(tab);
  for (let i=0;i<tab.seriesCount;i++){
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = tab.styles[i].name || ("Y"+(i+1));
    sel.appendChild(opt);
  }
  sel.value = String(clamp(tab.meta.focusY||0, 0, tab.seriesCount-1));
}

function loadTabToUI(){
  const tab = activeTab();
  ensureStyles(tab);

  $("#title").value = tab.meta.title || "";
  $("#xLabel").value = tab.meta.xLabel || "X";
  $("#yLabel").value = tab.meta.yLabel || "Y";
  $("#xMode").value = tab.meta.xMode || "auto";
  $("#sortX").value = tab.meta.sortX || "auto";
  $("#chartType").value = tab.meta.chartType || "line";
  $("#chkLogY").checked = !!tab.meta.logY;
  $("#chkMA").checked = !!tab.meta.ma;
  $("#maWindow").value = String(tab.meta.maWindow || 5);

  rebuildFocusY(tab);
  rebuildHeader(tab);
  rebuildGridFromTab(tab);
  renderTabs();

  // keep view state
  view.zoomX = tab.view.zoomX ?? 1;
  view.zoomY = tab.view.zoomY ?? 1;
  view.panX = tab.view.panX ?? 0;
  view.panY = tab.view.panY ?? 0;

  // render
  analyzeAndRender(false);
}

/* ---------- Theme / presentation ---------- */
function applyTheme(){
  document.body.dataset.theme = state.theme;
  $("#btnTheme").textContent = state.theme==="light" ? "Tema: Claro" : "Tema: Escuro";
}
function toggleTheme(){
  state.theme = (state.theme==="dark") ? "light" : "dark";
  applyTheme();
  autosave();
  render();
}
function togglePresentation(){
  state.presentation = !state.presentation;
  document.body.classList.toggle("presentation", state.presentation);
  $("#btnPresent").textContent = state.presentation ? "Sair apresentação" : "Apresentação";
  setTimeout(()=> resizeCanvas(), 50);
}

/* ---------- Stats core ---------- */
function quantileSorted(arr, q){
  if (!arr.length) return NaN;
  if (q<=0) return arr[0];
  if (q>=1) return arr[arr.length-1];
  const pos = (arr.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  const a = arr[base];
  const b = arr[Math.min(base+1, arr.length-1)];
  return a + (b - a) * rest;
}
function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
function variance(arr){
  if (arr.length<2) return NaN;
  const m = mean(arr);
  let s=0; for (const x of arr) s += (x-m)*(x-m);
  return s/(arr.length-1);
}
function stdev(arr){ const v=variance(arr); return Number.isFinite(v)? Math.sqrt(v):NaN; }
function skewness(arr){
  if (arr.length<3) return NaN;
  const m = mean(arr);
  const sd = stdev(arr);
  if (!Number.isFinite(sd) || sd===0) return NaN;
  let s3=0; for (const x of arr) s3 += Math.pow((x-m)/sd,3);
  return (arr.length/((arr.length-1)*(arr.length-2))) * s3;
}
function kurtosisExcess(arr){
  if (arr.length<4) return NaN;
  const m = mean(arr);
  const sd = stdev(arr);
  if (!Number.isFinite(sd) || sd===0) return NaN;
  let s4=0; for (const x of arr) s4 += Math.pow((x-m)/sd,4);
  const n = arr.length;
  // unbiased excess kurtosis
  return (n*(n+1)/((n-1)*(n-2)*(n-3)))*s4 - (3*(n-1)*(n-1)/((n-2)*(n-3)));
}
function median(arr){
  const s = [...arr].sort((a,b)=>a-b);
  return quantileSorted(s, 0.5);
}
function mad(arr){ // median absolute deviation
  if (!arr.length) return NaN;
  const med = median(arr);
  const dev = arr.map(x=>Math.abs(x-med)).sort((a,b)=>a-b);
  return quantileSorted(dev, 0.5);
}
function iqr(sorted){
  return quantileSorted(sorted, 0.75) - quantileSorted(sorted, 0.25);
}
function corr(x,y){
  const n = Math.min(x.length,y.length);
  if (n<2) return NaN;
  const mx = mean(x), my = mean(y);
  let sxx=0, syy=0, sxy=0;
  for(let i=0;i<n;i++){
    const dx = x[i]-mx;
    const dy = y[i]-my;
    sxx += dx*dx;
    syy += dy*dy;
    sxy += dx*dy;
  }
  const den = Math.sqrt(sxx*syy);
  if (!Number.isFinite(den) || den===0) return NaN;
  return sxy/den;
}
function movingAverage(xs, w){
  if (w<2) return xs.slice();
  const out = [];
  let sum = 0;
  const q = [];
  for (const x of xs){
    q.push(x);
    sum += x;
    if (q.length > w) sum -= q.shift();
    out.push(sum / q.length);
  }
  return out;
}

/* ---------- Analysis pipeline ---------- */
function inferXMode(tab, xCells){
  const forced = tab.meta.xMode || "auto";
  if (forced !== "auto") return forced;

  // try datetime
  let dtOk=0, dtTot=0;
  for (const v of xCells){
    if (!v) continue;
    dtTot++;
    if (Number.isFinite(parseDateTimeToMs(v))) dtOk++;
  }
  if (dtTot>0 && dtOk/dtTot >= 0.8) return "datetime";

  // try numeric
  let nOk=0, nTot=0;
  for (const v of xCells){
    if (!v) continue;
    nTot++;
    if (Number.isFinite(parseNumberBR(v))) nOk++;
  }
  if (nTot>0 && nOk/nTot >= 0.8) return "numeric";

  return "category";
}

function buildDatasetFromTab(tab){
  ensureStyles(tab);
  const rows = tab.data || [];
  const xCells = rows.map(r=>r[0] ?? "");
  const xMode = inferXMode(tab, xCells);

  // parse X
  let Xnum = []; // numeric coordinate
  let Xlabel = []; // label for ticks/tooltips
  let Xraw = [];
  let catMap = new Map();
  let catOrder = [];

  for (const v0 of xCells){
    const v = String(v0??"").trim();
    Xraw.push(v);
    if (!v){
      Xnum.push(NaN);
      Xlabel.push("");
      continue;
    }
    if (xMode === "numeric"){
      const n = parseNumberBR(v);
      Xnum.push(n);
      Xlabel.push(v);
    } else if (xMode === "datetime"){
      const ms = parseDateTimeToMs(v);
      Xnum.push(ms);
      Xlabel.push(Number.isFinite(ms)? formatMsToLabel(ms): v);
    } else {
      if (!catMap.has(v)){
        catMap.set(v, catMap.size);
        catOrder.push(v);
      }
      Xnum.push(catMap.get(v));
      Xlabel.push(v);
    }
  }

  // parse Ys
  const Ys = [];
  const yRaw = [];
  for (let s=0;s<tab.seriesCount;s++){
    const arr = [];
    const raw = [];
    for (const r of rows){
      const v = String((r?.[s+1] ?? "")).trim();
      raw.push(v);
      const n = parseNumberBR(v);
      arr.push(n);
    }
    Ys.push(arr);
    yRaw.push(raw);
  }

  // build points per series
  const series = [];
  for (let s=0;s<tab.seriesCount;s++){
    const pts = [];
    let missing=0;
    for (let i=0;i<rows.length;i++){
      const x = Xnum[i], y = Ys[s][i];
      if (!Number.isFinite(x) || !Number.isFinite(y)) { missing++; continue; }
      pts.push({ x, y, i, xLabel: Xlabel[i], xRaw: Xraw[i], yRaw: yRaw[s][i] });
    }
    series.push({ index:s, name: tab.styles[s].name || ("Y"+(s+1)), pts, missing, rawY: Ys[s], style: tab.styles[s], visible: tab.visible[s]!==false });
  }

  // sort if desired and numeric/datetime
  const shouldSort = (tab.meta.sortX==="yes") || (tab.meta.sortX==="auto" && (xMode==="numeric" || xMode==="datetime"));
  if (shouldSort){
    for (const s of series){
      s.pts.sort((a,b)=>a.x-b.x);
    }
  }

  return { xMode, Xnum, Xlabel, series, catOrder };
}

function computeStatsForSeries(values){
  const clean = values.filter(v=>Number.isFinite(v));
  const n = clean.length;
  const missing = values.length - n;
  if (!n) return { n:0, missing, min:NaN, max:NaN };

  clean.sort((a,b)=>a-b);
  const mn = clean[0];
  const mx = clean[clean.length-1];
  const m = mean(clean);
  const med = quantileSorted(clean, 0.5);
  const p05 = quantileSorted(clean, 0.05);
  const p10 = quantileSorted(clean, 0.10);
  const p25 = quantileSorted(clean, 0.25);
  const p75 = quantileSorted(clean, 0.75);
  const p90 = quantileSorted(clean, 0.90);
  const p95 = quantileSorted(clean, 0.95);

  const varS = variance(clean);
  const sd = stdev(clean);
  const cv = (Number.isFinite(sd) && m!==0) ? sd/Math.abs(m) : NaN;
  const iqrV = p75 - p25;
  const madV = mad(clean);
  const skew = skewness(clean);
  const kurt = kurtosisExcess(clean);

  return {
    n, missing,
    min: mn, max: mx, range: mx-mn, sum: clean.reduce((a,b)=>a+b,0),
    mean: m, median: med,
    p05, p10, p25, p50: med, p75, p90, p95,
    var: varS, sd, cv,
    iqr: iqrV,
    mad: madV,
    skew, kurt
  };
}

function analyze(tab){
  const ds = buildDatasetFromTab(tab);

  // apply log/MA
  const logY = !!tab.meta.logY;
  const useMA = !!tab.meta.ma;
  const w = clamp(Number(tab.meta.maWindow||5), 2, 99);

  const seriesOut = ds.series.map(s=>{
    let pts = s.pts.map(p=>({ ...p }));
    if (logY){
      pts = pts.map(p=>{
        if (p.y <= 0) return { ...p, y: NaN };
        return { ...p, y: Math.log10(p.y) };
      }).filter(p=>Number.isFinite(p.y));
    }
    if (useMA){
      // compute MA over sorted order (by x if sorted, otherwise by input order if numeric/datetime; for categorical it's index)
      const ys = pts.map(p=>p.y);
      const ma = movingAverage(ys, w);
      pts = pts.map((p,i)=>({ ...p, y: ma[i], _smoothed:true }));
    }
    return { ...s, pts };
  });

  // bounds
  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  for (const s of seriesOut){
    if (!s.visible) continue;
    for (const p of s.pts){
      xmin=Math.min(xmin,p.x); xmax=Math.max(xmax,p.x);
      ymin=Math.min(ymin,p.y); ymax=Math.max(ymax,p.y);
    }
  }
  if (!Number.isFinite(xmin)){ xmin=0; xmax=1; ymin=0; ymax=1; }

  // per-series stats (use raw numeric Y, before log/MA; that's what users expect in stats)
  const stats = [];
  for (let i=0;i<tab.seriesCount;i++){
    stats.push(computeStatsForSeries(ds.series[i].rawY));
  }

  // correlation (Pearson) per Y vs X numeric/datetime only
  const corrs = [];
  for (let i=0;i<tab.seriesCount;i++){
    const x = [];
    const y = [];
    for (const p of ds.series[i].pts){
      if (Number.isFinite(p.x) && Number.isFinite(p.y)){
        x.push(p.x);
        y.push(p.y);
      }
    }
    corrs.push((ds.xMode==="numeric" || ds.xMode==="datetime") ? corr(x,y) : NaN);
  }

  return {
    ds: { ...ds, series: seriesOut },
    bounds: { xmin,xmax,ymin,ymax },
    stats, corrs,
    logY, useMA, w
  };
}

/* ---------- Render stats UI ---------- */
function renderStats(tab){
  const a = tab.analysis;
  if (!a){ statsPanel.innerHTML=""; return; }
  statsPanel.innerHTML = "";

  for (let i=0;i<tab.seriesCount;i++){
    const s = tab.styles[i];
    const st = a.stats[i];
    const r = a.corrs[i];

    const el = document.createElement("div");
    el.className = "stat";
    el.innerHTML = `
      <div class="head">
        <span class="dot" style="background:${s.color}"></span>
        <span><strong>${escapeHtml(s.name||("Y"+(i+1)))}</strong></span>
        <span style="margin-left:auto" class="hint">n=${st.n} • faltantes=${st.missing}</span>
      </div>

      <div class="kvline"><span>min / max</span><span class="v">${fmt(st.min)} / ${fmt(st.max)}</span></div>
      <div class="kvline"><span>média / mediana</span><span class="v">${fmt(st.mean)} / ${fmt(st.median)}</span></div>
      <div class="kvline"><span>p25 / p50 / p75</span><span class="v">${fmt(st.p25)} / ${fmt(st.p50)} / ${fmt(st.p75)}</span></div>
      <div class="kvline"><span>p10 / p90</span><span class="v">${fmt(st.p10)} / ${fmt(st.p90)}</span></div>
      <div class="kvline"><span>desvio padrão (sd)</span><span class="v">${fmt(st.sd)}</span></div>
      <div class="kvline"><span>variância</span><span class="v">${fmt(st.var)}</span></div>
      <div class="kvline"><span>IQR / MAD</span><span class="v">${fmt(st.iqr)} / ${fmt(st.mad)}</span></div>
      <div class="kvline"><span>CV</span><span class="v">${fmt(st.cv)}</span></div>
      <div class="kvline"><span>assimetria / curtose</span><span class="v">${fmt(st.skew)} / ${fmt(st.kurt)}</span></div>
      <div class="kvline"><span>corr(X,Y)</span><span class="v">${Number.isFinite(r)? fmt(r,4): "—"}</span></div>
    `;
    statsPanel.appendChild(el);
  }
}

/* ---------- Series style panel + legend ---------- */
function renderSeriesPanel(tab){
  ensureStyles(tab);
  seriesPanel.innerHTML = "";

  for (let i=0;i<tab.seriesCount;i++){
    const s = tab.styles[i];

    const box = document.createElement("div");
    box.className = "stat";
    box.style.padding="10px";
    box.innerHTML = `
      <div class="head">
        <span class="dot" style="background:${s.color}"></span>
        <span><strong>Série ${i+1}</strong></span>
        <span style="margin-left:auto" class="hint">${tab.visible[i]!==false ? "visível" : "oculta"}</span>
      </div>

      <div class="row" style="gap:8px">
        <div class="field" style="min-width:180px">
          <div class="label">Nome</div>
          <input type="text" data-k="name" data-i="${i}" value="${escapeAttr(s.name)}"/>
        </div>
        <div class="field" style="min-width:140px; flex:0">
          <div class="label">Cor</div>
          <input type="text" data-k="color" data-i="${i}" value="${escapeAttr(s.color)}" placeholder="rgba(...)"/>
        </div>
        <div class="field" style="min-width:110px; flex:0">
          <div class="label">Linha</div>
          <input type="number" data-k="width" data-i="${i}" value="${s.width}" step="0.2" min="0.6" max="8"/>
        </div>
        <div class="field" style="min-width:110px; flex:0">
          <div class="label">Ponto</div>
          <input type="number" data-k="point" data-i="${i}" value="${s.point}" step="0.2" min="0" max="12"/>
        </div>
        <label class="check"><input type="checkbox" data-k="dashed" data-i="${i}" ${s.dashed?"checked":""}/> tracejada</label>
        <button class="btn small" data-toggle="${i}">${tab.visible[i]!==false ? "Ocultar" : "Mostrar"}</button>
      </div>
      <div class="hint">Dica: use “rgba(r,g,b,1)” ou copie do exemplo: ${palette[i%palette.length]}</div>
    `;
    seriesPanel.appendChild(box);
  }

  seriesPanel.querySelectorAll("input[data-k]").forEach(inp=>{
    inp.addEventListener("input", ()=>{
      const i = Number(inp.dataset.i);
      const k = inp.dataset.k;
      const tab = activeTab();
      const s = tab.styles[i];
      if (!s) return;
      if (k==="width" || k==="point"){
        s[k] = Number(inp.value||0);
      } else if (k==="dashed"){
        s[k] = inp.checked;
      } else {
        s[k] = inp.value;
      }
      rebuildFocusY(tab);
      autosave();
      render();
    });
  });

  seriesPanel.querySelectorAll("button[data-toggle]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const i = Number(btn.dataset.toggle);
      const tab = activeTab();
      tab.visible[i] = !(tab.visible[i]!==false);
      autosave();
      analyzeAndRender(false);
    });
  });
}

function renderLegend(tab){
  legendBox.innerHTML = "";
  ensureStyles(tab);
  for (let i=0;i<tab.seriesCount;i++){
    const s = tab.styles[i];
    const item = document.createElement("div");
    item.className = "item" + (tab.visible[i]===false ? " off" : "");
    item.innerHTML = `<span class="dot" style="background:${s.color}"></span><span>${escapeHtml(s.name||("Y"+(i+1)))}</span>`;
    item.addEventListener("click", ()=>{
      tab.visible[i] = (tab.visible[i]===false) ? true : false;
      autosave();
      analyzeAndRender(false);
    });
    legendBox.appendChild(item);
  }
}

/* ---------- Canvas / plot engine ---------- */
function devicePixelRatioSafe(){ return Math.min(2.25, window.devicePixelRatio || 1); }
function resizeCanvas(){
  const dpr = devicePixelRatioSafe();
  const rect = cv.getBoundingClientRect();
  const w = Math.max(420, Math.floor(rect.width));
  const h = Math.max(360, Math.floor(rect.height));
  cv.width = Math.floor(w * dpr);
  cv.height = Math.floor(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  render();
}
window.addEventListener("resize", ()=>resizeCanvas());

function rgbaToParts(rgba){
  const m = String(rgba).match(/rgba?\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)(?:\s*,\s*([0-9.]+))?\s*\)/i);
  if (!m) return null;
  return { r:+m[1], g:+m[2], b:+m[3], a: m[4]==null ? 1 : +m[4] };
}
function withAlpha(color, a){
  const p = rgbaToParts(color);
  if (!p) return color;
  return `rgba(${p.r},${p.g},${p.b},${a})`;
}

const view = { zoomX:1, zoomY:1, panX:0, panY:0 };
function saveViewToTab(){
  const tab = activeTab();
  tab.view.zoomX = view.zoomX;
  tab.view.zoomY = view.zoomY;
  tab.view.panX = view.panX;
  tab.view.panY = view.panY;
  autosave();
}

function niceStep(range){
  if (range<=0) return 1;
  const exp = Math.floor(Math.log10(range));
  const f = range / Math.pow(10, exp);
  let nf = 1;
  if (f < 1.5) nf = 1;
  else if (f < 3) nf = 2;
  else if (f < 7) nf = 5;
  else nf = 10;
  return nf * Math.pow(10, exp);
}
function drawAxes(plot){
  const {x0,y0,w,h, xmin,xmax,ymin,ymax, xMode, tab} = plot;

  const text = getCSS("--text");
  const muted = getCSS("--muted");
  const stroke = getCSS("--stroke");

  ctx.save();
  ctx.lineWidth = 1;

  // background subtle grid
  const gx = 6, gy = 5;
  ctx.strokeStyle = withAlpha(text, 0.09);
  for (let i=0;i<=gx;i++){
    const x = x0 + (w*i/gx);
    ctx.beginPath(); ctx.moveTo(x,y0); ctx.lineTo(x,y0+h); ctx.stroke();
  }
  for (let i=0;i<=gy;i++){
    const y = y0 + (h*i/gy);
    ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x0+w,y); ctx.stroke();
  }

  // border
  ctx.strokeStyle = stroke;
  ctx.strokeRect(x0,y0,w,h);

  // labels
  ctx.fillStyle = muted;
  ctx.font = "12px " + getCSS("--sans");
  ctx.fillText(tab.meta.xLabel || "X", x0 + 8, y0 + h + 30);
  ctx.save();
  ctx.translate(x0 - 34, y0 + h - 6);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(tab.meta.yLabel || "Y", 0, 0);
  ctx.restore();

  // ticks (X)
  ctx.fillStyle = withAlpha(text,0.7);
  ctx.font = "12px " + getCSS("--mono");

  const xticks = 6;
  for (let i=0;i<=xticks;i++){
    const x = x0 + (w*i/xticks);
    const xv = xmin + (xmax-xmin)*(i/xticks);
    let lab = "";
    if (xMode==="datetime") lab = formatMsToLabel(xv);
    else if (xMode==="category") {
      // show index ticks only
      lab = String(Math.round(xv));
    } else lab = fmt(xv, 4);
    if (lab.length>18) lab = lab.slice(0,18)+"…";
    ctx.fillText(lab, x-10, y0 + h + 18);
  }

  // ticks (Y)
  const yticks = 5;
  for (let i=0;i<=yticks;i++){
    const y = y0 + h - (h*i/yticks);
    const yv = ymin + (ymax-ymin)*(i/yticks);
    ctx.fillText(fmt(yv, 4), x0 + 8, y + 4);
  }

  // title
  ctx.fillStyle = withAlpha(text,0.9);
  ctx.font = "14px " + getCSS("--sans");
  ctx.fillText(tab.meta.title || "Análise", x0 + 8, y0 + 20);

  ctx.restore();
}

function worldToScreen(plot, x, y){
  const {x0,y0,w,h,xmin,xmax,ymin,ymax} = plot;
  const px = (x - xmin) / (xmax - xmin);
  const py = (y - ymin) / (ymax - ymin);
  return {
    sx: x0 + px*w,
    sy: y0 + h - py*h
  };
}
function screenToWorld(plot, sx, sy){
  const {x0,y0,w,h,xmin,xmax,ymin,ymax} = plot;
  const px = (sx - x0) / w;
  const py = (y0 + h - sy) / h;
  return {
    x: xmin + px*(xmax-xmin),
    y: ymin + py*(ymax-ymin)
  };
}

function getCSS(varName){
  return getComputedStyle(document.body).getPropertyValue(varName).trim();
}

function computeViewBounds(bounds){
  // apply zoom/pan around center
  let {xmin,xmax,ymin,ymax} = bounds;
  const cx = (xmin+xmax)/2;
  const cy = (ymin+ymax)/2;

  const rx = (xmax-xmin)/2 / view.zoomX;
  const ry = (ymax-ymin)/2 / view.zoomY;

  xmin = cx - rx + view.panX*rx*2;
  xmax = cx + rx + view.panX*rx*2;
  ymin = cy - ry + view.panY*ry*2;
  ymax = cy + ry + view.panY*ry*2;

  // padding
  const padx = (xmax-xmin)*0.04;
  const pady = (ymax-ymin)*0.08;
  xmin -= padx; xmax += padx;
  ymin -= pady; ymax += pady;

  if (xmin===xmax){ xmin-=1; xmax+=1; }
  if (ymin===ymax){ ymin-=1; ymax+=1; }

  return {xmin,xmax,ymin,ymax};
}

/* ---------- Plot types ---------- */
function render(){
  const tab = activeTab();
  const rect = cv.getBoundingClientRect();
  if (rect.width<10 || rect.height<10) return;

  ctx.clearRect(0,0,cv.width,cv.height);

  const pad = 58;
  const x0 = 60;
  const y0 = 18;
  const w = rect.width - x0 - 18;
  const h = rect.height - y0 - pad;

  if (!tab.analysis){
    // placeholder
    ctx.save();
    ctx.fillStyle = withAlpha(getCSS("--muted"), 0.9);
    ctx.font = "14px " + getCSS("--sans");
    ctx.fillText("Insira dados na planilha e clique em “Analisar + Gráficos”.", 18, 48);
    ctx.restore();
    return;
  }

  const a = tab.analysis;
  const ds = a.ds;
  const bounds = computeViewBounds(a.bounds);

  const plot = { x0,y0,w,h, ...bounds, xMode: ds.xMode, tab };

  drawAxes(plot);

  // draw chart
  const type = tab.meta.chartType || "line";
  if (type==="line" || type==="scatter"){
    drawLineScatter(plot, ds.series, type==="line");
  } else if (type==="hist"){
    drawHist(plot, ds, tab.meta.focusY||0);
  } else if (type==="box"){
    drawBox(plot, ds, tab.meta.focusY||0);
  } else if (type==="ecdf"){
    drawECDF(plot, ds, tab.meta.focusY||0);
  }

  // cache for tooltip nearest lookup
  lastPlot = plot;
  lastSeriesForPick = ds.series;
}

function drawLineScatter(plot, series, connect){
  const text = getCSS("--text");
  ctx.save();
  for (const s of series){
    const tab = plot.tab;
    const idx = s.index;
    if (tab.visible[idx]===false) continue;

    const style = s.style;
    const pts = s.pts;
    if (!pts.length) continue;

    // line
    if (connect){
      ctx.beginPath();
      let started = false;
      for (const p of pts){
        const {sx,sy} = worldToScreen(plot,p.x,p.y);
        if (!started){ ctx.moveTo(sx,sy); started = true; }
        else ctx.lineTo(sx,sy);
      }
      ctx.lineWidth = Math.max(0.6, style.width||2.2);
      ctx.strokeStyle = style.color;
      if (style.dashed) ctx.setLineDash([8,6]); else ctx.setLineDash([]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // points
    const pr = Math.max(0, style.point||4.3);
    if (pr>0){
      ctx.fillStyle = style.color;
      ctx.strokeStyle = withAlpha(text, 0.15);
      ctx.lineWidth = 1;
      for (const p of pts){
        const {sx,sy} = worldToScreen(plot,p.x,p.y);
        ctx.beginPath();
        ctx.arc(sx,sy, pr, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }
    }
  }
  ctx.restore();
}

function drawHist(plot, ds, focusIdx){
  const tab = plot.tab;
  const idx = clamp(Number(focusIdx||0), 0, tab.seriesCount-1);
  if (tab.visible[idx]===false){
    ctx.save();
    ctx.fillStyle = withAlpha(getCSS("--muted"),0.95);
    ctx.font = "13px " + getCSS("--sans");
    ctx.fillText("Série está oculta. Ative na legenda.", plot.x0+10, plot.y0+44);
    ctx.restore();
    return;
  }
  const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v));
  if (!raw.length) return;

  raw.sort((a,b)=>a-b);

  // bins (Freedman–Diaconis)
  const q1 = quantileSorted(raw,0.25);
  const q3 = quantileSorted(raw,0.75);
  const bw = (q3-q1) ? 2*(q3-q1)/Math.cbrt(raw.length) : 0;
  const min = raw[0], max = raw[raw.length-1];
  let bins = 12;
  if (bw>0) bins = clamp(Math.round((max-min)/bw), 6, 40);
  const step = (max-min) / bins || 1;

  const counts = Array.from({length:bins}, ()=>0);
  for (const v of raw){
    let b = Math.floor((v-min)/step);
    if (b===bins) b=bins-1;
    counts[clamp(b,0,bins-1)]++;
  }
  const cmax = Math.max(...counts);

  ctx.save();
  const color = tab.styles[idx].color;
  ctx.fillStyle = withAlpha(color, 0.35);
  ctx.strokeStyle = withAlpha(color, 0.95);
  ctx.lineWidth = 1;

  for (let i=0;i<bins;i++){
    const x1 = min + i*step;
    const x2 = x1 + step;
    const yv = counts[i];
    const {sx:s1,sy:base} = worldToScreen(plot, x1, plot.ymin);
    const {sx:s2} = worldToScreen(plot, x2, plot.ymin);
    const barW = Math.max(1, (s2-s1) - 2);
    const yTop = plot.ymin + (plot.ymax-plot.ymin) * (yv/cmax);
    const {sy:top} = worldToScreen(plot, x1, yTop);
    ctx.beginPath();
    ctx.rect(s1+1, top, barW, base-top);
    ctx.fill();
    ctx.stroke();
  }

  ctx.restore();
}

function drawBox(plot, ds, focusIdx){
  const tab = plot.tab;
  const idx = clamp(Number(focusIdx||0), 0, tab.seriesCount-1);
  const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
  if (raw.length<2) return;

  const q1 = quantileSorted(raw,0.25);
  const q2 = quantileSorted(raw,0.50);
  const q3 = quantileSorted(raw,0.75);
  const iqrV = q3-q1;
  const lowFence = q1 - 1.5*iqrV;
  const highFence = q3 + 1.5*iqrV;

  let wMin = Infinity, wMax = -Infinity;
  const outliers = [];
  for (const v of raw){
    if (v<lowFence || v>highFence) outliers.push(v);
    else { wMin=Math.min(wMin,v); wMax=Math.max(wMax,v); }
  }

  // draw centered box at X mid
  const cx = (plot.xmin+plot.xmax)/2;
  const boxW = (plot.xmax-plot.xmin)*0.22;
  const color = tab.styles[idx].color;

  const xL = cx - boxW/2;
  const xR = cx + boxW/2;

  const pQ1 = worldToScreen(plot, xL, q1);
  const pQ3 = worldToScreen(plot, xR, q3);
  const pMedL = worldToScreen(plot, xL, q2);
  const pMedR = worldToScreen(plot, xR, q2);
  const pWmin = worldToScreen(plot, cx, wMin);
  const pWmax = worldToScreen(plot, cx, wMax);
  const pQ1c = worldToScreen(plot, cx, q1);
  const pQ3c = worldToScreen(plot, cx, q3);

  ctx.save();
  ctx.fillStyle = withAlpha(color, 0.25);
  ctx.strokeStyle = withAlpha(color, 0.95);
  ctx.lineWidth = 2;

  // box
  ctx.beginPath();
  ctx.rect(pQ1.sx, pQ3.sy, pQ3.sx - pQ1.sx, pQ1.sy - pQ3.sy);
  ctx.fill();
  ctx.stroke();

  // median
  ctx.beginPath(); ctx.moveTo(pMedL.sx, pMedL.sy); ctx.lineTo(pMedR.sx, pMedR.sy); ctx.stroke();

  // whiskers
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(pWmin.sx, pWmin.sy); ctx.lineTo(pQ1c.sx, pQ1c.sy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(pWmax.sx, pWmax.sy); ctx.lineTo(pQ3c.sx, pQ3c.sy); ctx.stroke();

  // caps
  const capW = (pQ3.sx - pQ1.sx)*0.5;
  ctx.beginPath(); ctx.moveTo(pWmin.sx-capW/2, pWmin.sy); ctx.lineTo(pWmin.sx+capW/2, pWmin.sy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(pWmax.sx-capW/2, pWmax.sy); ctx.lineTo(pWmax.sx+capW/2, pWmax.sy); ctx.stroke();

  // outliers
  ctx.fillStyle = withAlpha(color, 0.95);
  ctx.strokeStyle = withAlpha(getCSS("--text"), 0.12);
  for (const v of outliers){
    const p = worldToScreen(plot, cx, v);
    ctx.beginPath();
    ctx.arc(p.sx, p.sy, 4.3, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
  }

  ctx.restore();
}

function drawECDF(plot, ds, focusIdx){
  const tab = plot.tab;
  const idx = clamp(Number(focusIdx||0), 0, tab.seriesCount-1);
  const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
  if (!raw.length) return;
  const n = raw.length;
  const color = tab.styles[idx].color;

  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2.2;
  ctx.setLineDash([]);

  ctx.beginPath();
  for (let i=0;i<n;i++){
    const x = raw[i];
    const y = (i+1)/n;
    const p = worldToScreen(plot, x, y);
    if (i===0) ctx.moveTo(p.sx, p.sy);
    else ctx.lineTo(p.sx, p.sy);
  }
  ctx.stroke();

  // points
  ctx.fillStyle = color;
  for (let i=0;i<n;i+=Math.ceil(n/40)){
    const x = raw[i];
    const y = (i+1)/n;
    const p = worldToScreen(plot, x, y);
    ctx.beginPath(); ctx.arc(p.sx,p.sy,3.8,0,Math.PI*2); ctx.fill();
  }

  ctx.restore();
}

/* ---------- Tooltip picking ---------- */
let lastPlot = null;
let lastSeriesForPick = null;

function showTooltip(x,y, html){
  tooltip.style.left = (x+12)+"px";
  tooltip.style.top = (y+12)+"px";
  tooltip.innerHTML = html;
  tooltip.style.display = "block";
}
function hideTooltip(){ tooltip.style.display="none"; }

function pickNearest(screenX, screenY){
  if (!lastPlot || !lastSeriesForPick) return null;
  const tab = lastPlot.tab;
  let best = null;
  let bestD = Infinity;

  for (const s of lastSeriesForPick){
    if (tab.visible[s.index]===false) continue;
    const style = s.style;
    const pr = Math.max(2.5, style.point||4.3);
    for (const p of s.pts){
      const sp = worldToScreen(lastPlot, p.x, p.y);
      const dx = sp.sx - screenX;
      const dy = sp.sy - screenY;
      const d = Math.sqrt(dx*dx + dy*dy);
      if (d < bestD){
        bestD = d;
        best = { s, p, sp, d };
      }
    }
  }
  if (!best) return null;
  const threshold = 18; // px
  if (best.d > threshold) return null;
  return best;
}

/* ---------- Interaction: mouse + touch zoom/pan ---------- */
let dragging = false;
let lastPt = null;
let pinch = null;

cv.addEventListener("mousemove", (e)=>{
  const rect = cv.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  if (dragging && lastPt){
    const dx = x - lastPt.x;
    const dy = y - lastPt.y;
    // pan normalized
    view.panX += dx / Math.max(200, rect.width) / view.zoomX;
    view.panY -= dy / Math.max(200, rect.height) / view.zoomY;
    lastPt = {x,y};
    saveViewToTab();
    render();
    return;
  }

  const hit = pickNearest(x,y);
  if (hit){
    const tab = activeTab();
    const xMode = tab.analysis?.ds?.xMode || "numeric";
    const xLab = (xMode==="category"||xMode==="numeric"||xMode==="datetime") ? (hit.p.xLabel ?? hit.p.xRaw) : hit.p.xRaw;
    const yLab = hit.p._smoothed ? `${fmt(hit.p.y)} (suavizado)` : fmt(hit.p.y);
    showTooltip(e.clientX, e.clientY, `
      <div class="t"><span class="dot" style="background:${hit.s.style.color}"></span>${escapeHtml(hit.s.name)}</div>
      <div class="kv"><span>X</span><span class="v">${escapeHtml(String(xLab??""))}</span></div>
      <div class="kv"><span>Y</span><span class="v">${escapeHtml(String(yLab??""))}</span></div>
      <div class="kv"><span>Linha</span><span class="v">${hit.p.i+1}</span></div>
    `);
  } else hideTooltip();
});

cv.addEventListener("mouseleave", ()=> hideTooltip());

cv.addEventListener("mousedown", (e)=>{
  dragging = true;
  const rect = cv.getBoundingClientRect();
  lastPt = { x: e.clientX - rect.left, y: e.clientY - rect.top };
});
window.addEventListener("mouseup", ()=>{ dragging=false; lastPt=null; });

cv.addEventListener("wheel", (e)=>{
  e.preventDefault();
  const rect = cv.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const delta = -e.deltaY;
  const zoomFactor = Math.exp(delta * 0.0012);
  // zoom around pointer: approximate by modifying pan a bit
  const before = screenToWorld(lastPlot || {
    x0:60,y0:18,w:rect.width-78,h:rect.height-76,
    xmin:0,xmax:1,ymin:0,ymax:1
  }, mx, my);

  view.zoomX = clamp(view.zoomX * zoomFactor, 0.25, 40);
  view.zoomY = clamp(view.zoomY * zoomFactor, 0.25, 40);

  const after = screenToWorld(lastPlot || {
    x0:60,y0:18,w:rect.width-78,h:rect.height-76,
    xmin:0,xmax:1,ymin:0,ymax:1
  }, mx, my);

  // compensate pan by difference in world coords, normalized
  const dxWorld = after.x - before.x;
  const dyWorld = after.y - before.y;
  // convert to normalized pan in view space (rough but works well)
  view.panX += (dxWorld / Math.max(1e-9, (lastPlot?.xmax-lastPlot?.xmin) || 1));
  view.panY += (dyWorld / Math.max(1e-9, (lastPlot?.ymax-lastPlot?.ymin) || 1));

  saveViewToTab();
  render();
}, {passive:false});

/* Touch: pan + pinch zoom */
cv.addEventListener("touchstart",(e)=>{
  const rect = cv.getBoundingClientRect();
  if (e.touches.length===1){
    dragging = true;
    const t = e.touches[0];
    lastPt = { x: t.clientX - rect.left, y: t.clientY - rect.top };
  } else if (e.touches.length===2){
    dragging = false;
    const a = e.touches[0], b = e.touches[1];
    const ax=a.clientX-rect.left, ay=a.clientY-rect.top;
    const bx=b.clientX-rect.left, by=b.clientY-rect.top;
    pinch = {
      dist: Math.hypot(ax-bx, ay-by),
      zoomX: view.zoomX,
      zoomY: view.zoomY,
      mid: { x:(ax+bx)/2, y:(ay+by)/2 }
    };
  }
},{passive:true});

cv.addEventListener("touchmove",(e)=>{
  const rect = cv.getBoundingClientRect();
  if (e.touches.length===1 && dragging && lastPt){
    const t = e.touches[0];
    const x = t.clientX - rect.left, y = t.clientY - rect.top;
    const dx = x - lastPt.x;
    const dy = y - lastPt.y;
    view.panX += dx / Math.max(200, rect.width) / view.zoomX;
    view.panY -= dy / Math.max(200, rect.height) / view.zoomY;
    lastPt = {x,y};
    saveViewToTab();
    render();
  } else if (e.touches.length===2 && pinch){
    const a = e.touches[0], b = e.touches[1];
    const ax=a.clientX-rect.left, ay=a.clientY-rect.top;
    const bx=b.clientX-rect.left, by=b.clientY-rect.top;
    const dist = Math.hypot(ax-bx, ay-by);
    const factor = dist / Math.max(1, pinch.dist);
    view.zoomX = clamp(pinch.zoomX * factor, 0.25, 40);
    view.zoomY = clamp(pinch.zoomY * factor, 0.25, 40);
    saveViewToTab();
    render();
  }
},{passive:true});

cv.addEventListener("touchend",()=>{
  dragging=false; lastPt=null; pinch=null;
},{passive:true});

/* ---------- Analyze + render ---------- */
function analyzeAndRender(showToast=true){
  const tab = activeTab();
  syncUIToTab();
  try{
    tab.analysis = analyze(tab);
    renderLegend(tab);
    renderSeriesPanel(tab);
    renderStats(tab);
    render();
    if (showToast) toast("ok","Atualizado","Análise e gráficos recalculados.");
  }catch(e){
    tab.analysis = null;
    render();
    toast("err","Erro ao analisar", String(e?.message||e));
  }
}

/* ---------- UI events ---------- */
$("#btnAnalyze").addEventListener("click", ()=> analyzeAndRender(true));
$("#btnReset").addEventListener("click", ()=>{
  view.zoomX=1; view.zoomY=1; view.panX=0; view.panY=0;
  saveViewToTab();
  render();
  toast("ok","Zoom resetado","Voltou ao enquadramento padrão.");
});

$("#btnAddRow").addEventListener("click", ()=> addRow());
$("#btnAddSeries").addEventListener("click", ()=> addSeries());
$("#btnNewTab").addEventListener("click", ()=> newTab());

$("#btnClear").addEventListener("click", ()=>{
  const tab = activeTab();
  tab.seriesCount = 1;
  tab.styles = [{ name:"Y1", color: palette[0], width:2.2, point:4.3, dashed:false }];
  tab.visible = [true];
  tab.data = Array.from({length:14}, ()=>["",""]);
  tab.meta = {...tab.meta, chartType:"line", focusY:0, logY:false, ma:false, maWindow:5};
  tab.analysis = null;
  view.zoomX=1; view.zoomY=1; view.panX=0; view.panY=0;
  rebuildFocusY(tab);
  rebuildHeader(tab);
  rebuildGridFromTab(tab);
  renderTabs();
  autosave();
  render();
  toast("ok","Limpo","Aba resetada.");
});

$("#btnExample").addEventListener("click", ()=>{
  const tab = activeTab();
  tab.seriesCount = 2;
  ensureStyles(tab);
  tab.styles[0].name = "Temperatura";
  tab.styles[1].name = "Pressão";
  tab.data = [];
  for (let i=0;i<30;i++){
    const x = i+1;
    const y1 = (20 + 4*Math.sin(i/4) + Math.random()*0.8).toFixed(2).replace(".",",");
    const y2 = (100 + 8*Math.cos(i/6) + Math.random()*1.2).toFixed(2).replace(".",",");
    tab.data.push([String(x), y1, y2]);
  }
  tab.meta.title = "Exemplo: séries vs X";
  tab.meta.xMode = "numeric";
  tab.meta.sortX = "yes";
  rebuildFocusY(tab);
  rebuildHeader(tab);
  rebuildGridFromTab(tab);
  autosave();
  analyzeAndRender(true);
});

["#title","#xLabel","#yLabel","#xMode","#sortX","#chartType","#focusY","#chkLogY","#chkMA","#maWindow"].forEach(sel=>{
  $(sel).addEventListener("input", ()=>{
    syncUIToTab();
    autosave();
    // render fast, analyze on demand (but for chartType/focus/log/ma it's useful instantly)
    if (["#chartType","#focusY","#chkLogY","#chkMA","#maWindow","#xMode","#sortX"].includes(sel)){
      analyzeAndRender(false);
    } else render();
  });
});

/* Grid editing: autosave + optional analyze shortcut */
tbody.addEventListener("input", ()=> autosave());

/* Paste support */
tbody.addEventListener("paste", async (e)=>{
  const target = e.target;
  if (!(target instanceof HTMLInputElement) || !target.classList.contains("cell")) return;

  const text = (e.clipboardData || window.clipboardData)?.getData("text") || "";
  const rows = parseGridText(text);
  if (!rows || rows.length===0) return;

  // if single cell, let default happen
  if (rows.length===1 && (rows[0]?.length||0)===1) return;

  e.preventDefault();
  pasteIntoGrid(target, rows);
});

/* ---------- Command palette ---------- */
const commands = [
  {name:"Analisar + Gráficos", desc:"Recalcula estatística e redesenha", keys:["Ctrl+Enter"], run:()=>analyzeAndRender(true)},
  {name:"Importar CSV/TSV/JSON", desc:"Carrega dados de arquivo", keys:[""], run:()=>$("#fileImport").click()},
  {name:"Salvar Projeto (JSON)", desc:"Exporta o projeto completo", keys:[""], run:()=>exportProjectJSON()},
  {name:"Carregar Projeto (JSON)", desc:"Restaura um projeto salvo", keys:[""], run:()=>$("#fileJSON").click()},
  {name:"Exportar PNG", desc:"Baixa a imagem do gráfico atual", keys:[""], run:()=>exportPNG()},
  {name:"Exportar SVG", desc:"Baixa SVG vetorial do gráfico", keys:[""], run:()=>exportSVG()},
  {name:"Tema (claro/escuro)", desc:"Alterna o tema", keys:[""], run:()=>toggleTheme()},
  {name:"Apresentação (full)", desc:"Modo tela cheia e clean", keys:[""], run:()=>togglePresentation()},
  {name:"Reset zoom/pan", desc:"Volta ao enquadramento padrão", keys:[""], run:()=>$("#btnReset").click()},
  {name:"Nova aba", desc:"Cria uma aba nova", keys:[""], run:()=>newTab()},
  {name:"Adicionar linha", desc:"Insere uma linha na planilha", keys:[""], run:()=>addRow()},
  {name:"Adicionar série", desc:"Cria uma nova coluna Y", keys:[""], run:()=>addSeries()},
  {name:"Exemplo", desc:"Preenche dados de demonstração", keys:[""], run:()=>$("#btnExample").click()},
  {name:"Relatório / Print", desc:"Imprimir como PDF (navegador)", keys:[""], run:()=>window.print()},
];

function openCmd(){
  overlay.style.display="flex";
  cmdSearch.value="";
  renderCmdList("");
  setTimeout(()=>cmdSearch.focus(), 0);
}
function closeCmd(){
  overlay.style.display="none";
}
function renderCmdList(q){
  const qq = q.trim().toLowerCase();
  const items = commands.filter(c=>{
    if (!qq) return true;
    return (c.name+" "+c.desc).toLowerCase().includes(qq);
  });

  cmdList.innerHTML="";
  for (const c of items){
    const el = document.createElement("div");
    el.className="cmd";
    el.innerHTML = `
      <div class="left">
        <div class="name">${escapeHtml(c.name)}</div>
        <div class="desc">${escapeHtml(c.desc)}</div>
      </div>
      <div class="right">
        ${(c.keys||[]).filter(Boolean).map(k=>`<span class="pill">${escapeHtml(k)}</span>`).join("")}
      </div>
    `;
    el.addEventListener("click", ()=>{
      closeCmd();
      c.run();
    });
    cmdList.appendChild(el);
  }
}

$("#btnCmd").addEventListener("click", ()=>openCmd());
overlay.addEventListener("click", (e)=>{ if (e.target===overlay) closeCmd(); });
cmdSearch.addEventListener("input", ()=>renderCmdList(cmdSearch.value));
window.addEventListener("keydown",(e)=>{
  const isMac = /Mac|iPhone|iPad|iPod/.test(navigator.platform);
  const ctrl = isMac ? e.metaKey : e.ctrlKey;

  if (ctrl && e.key.toLowerCase()==="k"){
    e.preventDefault();
    openCmd();
  }
  if (ctrl && e.key==="Enter"){
    e.preventDefault();
    analyzeAndRender(true);
  }
  if (e.key==="Escape"){
    closeCmd();
  }
});

/* ---------- Buttons: theme/present ---------- */
$("#btnTheme").addEventListener("click", ()=>toggleTheme());
$("#btnPresent").addEventListener("click", ()=>togglePresentation());

/* ---------- Import buttons ---------- */
$("#btnImport").addEventListener("click", ()=>$("#fileImport").click());
$("#fileImport").addEventListener("change", async (e)=>{
  const f = e.target.files?.[0];
  e.target.value="";
  if (!f) return;
  await importAny(f);
});

/* ---------- Save/Load JSON ---------- */
$("#btnSaveJSON").addEventListener("click", ()=>exportProjectJSON());
$("#btnLoadJSON").addEventListener("click", ()=>$("#fileJSON").click());
$("#fileJSON").addEventListener("change",(e)=>{
  const f = e.target.files?.[0];
  e.target.value="";
  if (!f) return;
  importProjectJSON(f);
});

/* ---------- Report ---------- */
$("#btnReport").addEventListener("click", ()=>window.print());

/* ---------- Export PNG/SVG ---------- */
function exportPNG(){
  // ensure up-to-date
  analyzeAndRender(false);
  const a = document.createElement("a");
  a.download = "grafico.png";
  a.href = cv.toDataURL("image/png");
  a.click();
  toast("ok","Export PNG","Imagem do gráfico baixada.");
}
$("#btnPNG").addEventListener("click", ()=>exportPNG());

function exportSVG(){
  analyzeAndRender(false);
  const tab = activeTab();
  if (!tab.analysis){ toast("err","Sem dados","Analise antes de exportar."); return; }

  const rect = cv.getBoundingClientRect();
  const width = Math.max(640, Math.round(rect.width));
  const height = Math.max(420, Math.round(rect.height));

  // re-create plot dimensions consistent with canvas render
  const x0 = 60, y0 = 18;
  const w = width - x0 - 18;
  const h = height - y0 - 58;

  const bounds = computeViewBounds(tab.analysis.bounds);
  const plot = { x0,y0,w,h, ...bounds, xMode: tab.analysis.ds.xMode, tab };

  const svg = [];
  const bg = getComputedStyle(document.body).getPropertyValue("--panel").trim() || "rgba(255,255,255,0.06)";
  const stroke = getComputedStyle(document.body).getPropertyValue("--stroke").trim() || "rgba(255,255,255,0.12)";
  const text = getComputedStyle(document.body).getPropertyValue("--text").trim() || "rgba(255,255,255,0.9)";
  const muted = getComputedStyle(document.body).getPropertyValue("--muted").trim() || "rgba(255,255,255,0.62)";
  const mono = "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace";
  const sans = "ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Noto Sans', 'Liberation Sans', sans-serif";

  function esc(s){ return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

  function w2s(x,y){
    const px = (x - plot.xmin) / (plot.xmax - plot.xmin);
    const py = (y - plot.ymin) / (plot.ymax - plot.ymin);
    return { sx: plot.x0 + px*plot.w, sy: plot.y0 + plot.h - py*plot.h };
  }

  svg.push(`<?xml version="1.0" encoding="UTF-8"?>`);
  svg.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`);
  svg.push(`<rect x="0" y="0" width="${width}" height="${height}" fill="${bg}" opacity="0.55"/>`);

  // grid
  const gx=6, gy=5;
  for(let i=0;i<=gx;i++){
    const x = x0 + (w*i/gx);
    svg.push(`<line x1="${x}" y1="${y0}" x2="${x}" y2="${y0+h}" stroke="${withAlpha(text,0.09)}" stroke-width="1"/>`);
  }
  for(let i=0;i<=gy;i++){
    const y = y0 + (h*i/gy);
    svg.push(`<line x1="${x0}" y1="${y}" x2="${x0+w}" y2="${y}" stroke="${withAlpha(text,0.09)}" stroke-width="1"/>`);
  }

  // border
  svg.push(`<rect x="${x0}" y="${y0}" width="${w}" height="${h}" fill="none" stroke="${stroke}" stroke-width="1"/>`);

  // title and labels
  svg.push(`<text x="${x0+8}" y="${y0+20}" fill="${withAlpha(text,0.9)}" font-family="${sans}" font-size="14">${esc(tab.meta.title||"Análise")}</text>`);
  svg.push(`<text x="${x0+8}" y="${y0+h+30}" fill="${muted}" font-family="${sans}" font-size="12">${esc(tab.meta.xLabel||"X")}</text>`);
  svg.push(`<text x="${x0-34}" y="${y0+h-6}" fill="${muted}" font-family="${sans}" font-size="12" transform="rotate(-90 ${x0-34} ${y0+h-6})">${esc(tab.meta.yLabel||"Y")}</text>`);

  // ticks
  const xt=6;
  for(let i=0;i<=xt;i++){
    const xv = plot.xmin + (plot.xmax-plot.xmin)*(i/xt);
    let lab = tab.analysis.ds.xMode==="datetime" ? formatMsToLabel(xv) : fmt(xv,4);
    if (lab.length>18) lab = lab.slice(0,18)+"…";
    const x = x0 + (w*i/xt);
    svg.push(`<text x="${x-10}" y="${y0+h+18}" fill="${withAlpha(text,0.7)}" font-family="${mono}" font-size="12">${esc(lab)}</text>`);
  }
  const yt=5;
  for(let i=0;i<=yt;i++){
    const yv = plot.ymin + (plot.ymax-plot.ymin)*(i/yt);
    const y = y0 + h - (h*i/yt);
    svg.push(`<text x="${x0+8}" y="${y+4}" fill="${withAlpha(text,0.7)}" font-family="${mono}" font-size="12">${esc(fmt(yv,4))}</text>`);
  }

  // plot type
  const type = tab.meta.chartType || "line";
  const ds = tab.analysis.ds;

  if (type==="line" || type==="scatter"){
    for (const s of ds.series){
      if (tab.visible[s.index]===false) continue;
      const st = s.style;
      const pts = s.pts;
      if (!pts.length) continue;

      if (type==="line"){
        const d = pts.map((p,idx)=>{
          const q = w2s(p.x,p.y);
          return `${idx===0?"M":"L"} ${q.sx.toFixed(2)} ${q.sy.toFixed(2)}`;
        }).join(" ");
        const dash = st.dashed ? ` stroke-dasharray="8 6"` : "";
        svg.push(`<path d="${d}" fill="none" stroke="${st.color}" stroke-width="${Math.max(0.6,st.width||2.2)}"${dash}/>`);  
      }
      const pr = Math.max(0, st.point||4.3);
      if (pr>0){
        for (const p of pts){
          const q = w2s(p.x,p.y);
          svg.push(`<circle cx="${q.sx.toFixed(2)}" cy="${q.sy.toFixed(2)}" r="${pr}" fill="${st.color}" stroke="${withAlpha(text,0.15)}" stroke-width="1"/>`);
        }
      }
    }
  } else if (type==="hist"){
    const idx = clamp(Number(tab.meta.focusY||0), 0, tab.seriesCount-1);
    const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
    if (raw.length){
      const q1 = quantileSorted(raw,0.25), q3 = quantileSorted(raw,0.75);
      const bw = (q3-q1) ? 2*(q3-q1)/Math.cbrt(raw.length) : 0;
      const min = raw[0], max = raw[raw.length-1];
      let bins = 12;
      if (bw>0) bins = clamp(Math.round((max-min)/bw), 6, 40);
      const step = (max-min)/bins || 1;
      const counts = Array.from({length:bins}, ()=>0);
      for (const v of raw){
        let b = Math.floor((v-min)/step);
        if (b===bins) b=bins-1;
        counts[clamp(b,0,bins-1)]++;
      }
      const cmax = Math.max(...counts);
      const color = tab.styles[idx].color;

      for (let i=0;i<bins;i++){
        const x1 = min + i*step;
        const x2 = x1 + step;
        const yv = counts[i];
        const s1 = w2s(x1, plot.ymin);
        const s2 = w2s(x2, plot.ymin);
        const barW = Math.max(1, (s2.sx-s1.sx) - 2);
        const yTop = plot.ymin + (plot.ymax-plot.ymin) * (yv/cmax);
        const top = w2s(x1, yTop);
        svg.push(`<rect x="${(s1.sx+1).toFixed(2)}" y="${top.sy.toFixed(2)}" width="${barW.toFixed(2)}" height="${(s1.sy-top.sy).toFixed(2)}" fill="${withAlpha(color,0.35)}" stroke="${withAlpha(color,0.95)}" stroke-width="1"/>`);
      }
    }
  } else if (type==="box"){
    // simple vector boxplot (same as canvas)
    const idx = clamp(Number(tab.meta.focusY||0), 0, tab.seriesCount-1);
    const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
    if (raw.length>=2){
      const q1 = quantileSorted(raw,0.25);
      const q2 = quantileSorted(raw,0.50);
      const q3 = quantileSorted(raw,0.75);
      const iqrV = q3-q1;
      const lowFence = q1 - 1.5*iqrV;
      const highFence = q3 + 1.5*iqrV;

      let wMin = Infinity, wMax = -Infinity;
      const outliers = [];
      for (const v of raw){
        if (v<lowFence || v>highFence) outliers.push(v);
        else { wMin=Math.min(wMin,v); wMax=Math.max(wMax,v); }
      }
      const cx = (plot.xmin+plot.xmax)/2;
      const boxW = (plot.xmax-plot.xmin)*0.22;
      const xL = cx - boxW/2;
      const xR = cx + boxW/2;
      const color = tab.styles[idx].color;

      const pQ1 = w2s(xL, q1);
      const pQ3 = w2s(xR, q3);
      const pMedL = w2s(xL, q2);
      const pMedR = w2s(xR, q2);
      const pWmin = w2s(cx, wMin);
      const pWmax = w2s(cx, wMax);
      const pQ1c = w2s(cx, q1);
      const pQ3c = w2s(cx, q3);

      svg.push(`<rect x="${pQ1.sx.toFixed(2)}" y="${pQ3.sy.toFixed(2)}" width="${(pQ3.sx-pQ1.sx).toFixed(2)}" height="${(pQ1.sy-pQ3.sy).toFixed(2)}" fill="${withAlpha(color,0.25)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      svg.push(`<line x1="${pMedL.sx.toFixed(2)}" y1="${pMedL.sy.toFixed(2)}" x2="${pMedR.sx.toFixed(2)}" y2="${pMedR.sy.toFixed(2)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      svg.push(`<line x1="${pWmin.sx.toFixed(2)}" y1="${pWmin.sy.toFixed(2)}" x2="${pQ1c.sx.toFixed(2)}" y2="${pQ1c.sy.toFixed(2)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      svg.push(`<line x1="${pWmax.sx.toFixed(2)}" y1="${pWmax.sy.toFixed(2)}" x2="${pQ3c.sx.toFixed(2)}" y2="${pQ3c.sy.toFixed(2)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      const capW = (pQ3.sx - pQ1.sx)*0.5;
      svg.push(`<line x1="${(pWmin.sx-capW/2).toFixed(2)}" y1="${pWmin.sy.toFixed(2)}" x2="${(pWmin.sx+capW/2).toFixed(2)}" y2="${pWmin.sy.toFixed(2)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      svg.push(`<line x1="${(pWmax.sx-capW/2).toFixed(2)}" y1="${pWmax.sy.toFixed(2)}" x2="${(pWmax.sx+capW/2).toFixed(2)}" y2="${pWmax.sy.toFixed(2)}" stroke="${withAlpha(color,0.95)}" stroke-width="2"/>`);
      for (const v of outliers){
        const p = w2s(cx, v);
        svg.push(`<circle cx="${p.sx.toFixed(2)}" cy="${p.sy.toFixed(2)}" r="4.3" fill="${withAlpha(color,0.95)}" stroke="${withAlpha(text,0.12)}" stroke-width="1"/>`);
      }
    }
  } else if (type==="ecdf"){
    const idx = clamp(Number(tab.meta.focusY||0), 0, tab.seriesCount-1);
    const raw = ds.series[idx].rawY.filter(v=>Number.isFinite(v)).sort((a,b)=>a-b);
    if (raw.length){
      const n = raw.length;
      const color = tab.styles[idx].color;
      const d = raw.map((x,i)=>{
        const y = (i+1)/n;
        const p = w2s(x,y);
        return `${i===0?"M":"L"} ${p.sx.toFixed(2)} ${p.sy.toFixed(2)}`;
      }).join(" ");
      svg.push(`<path d="${d}" fill="none" stroke="${color}" stroke-width="2.2"/>`);
      const step = Math.ceil(n/40);
      for (let i=0;i<n;i+=step){
        const x = raw[i], y=(i+1)/n;
        const p = w2s(x,y);
        svg.push(`<circle cx="${p.sx.toFixed(2)}" cy="${p.sy.toFixed(2)}" r="3.8" fill="${color}"/>`);
      }
    }
  }

  svg.push(`</svg>`);
  download("grafico.svg", svg.join("\n"), "image/svg+xml");
  toast("ok","Export SVG","SVG vetorial baixado.");
}
$("#btnSVG").addEventListener("click", ()=>exportSVG());

/* ---------- Helpers: HTML escaping ---------- */
function escapeHtml(s){
  return String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");
}
function escapeAttr(s){ return escapeHtml(s).replace(/"/g,"&quot;"); }

/* ---------- Initial load ---------- */
(function init(){
  const ok = restoreAutosave();
  if (!ok){
    applyTheme();
  }
  renderTabs();
  loadTabToUI();
  resizeCanvas();
  // friendly toast once
  setTimeout(()=>toast("ok","Pronto","Insira dados e clique em “Analisar + Gráficos”."), 350);
})();

/* ---------- Extra buttons ---------- */
$("#btnReport").addEventListener("click", ()=>window.print());
</script>
</body>
</html>
