<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gráfico ULTRA (Tech) — 1 arquivo</title>
  <style>
    :root{
      --bg:#0b0f14; --text:#e8eef6; --muted:#a8b3c2;
      --radius:14px; --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family:var(--sans); color:var(--text);
      background: radial-gradient(1200px 800px at 20% 0%, #12203a 0%, var(--bg) 45%) fixed;
    }
    header{max-width:1320px;margin:0 auto;padding:18px 16px 10px}
    h1{margin:0 0 6px;font-size:18px}
    .sub{margin:0;color:var(--muted);font-size:13px;line-height:1.35}

    .wrap{
      max-width:1320px;margin:0 auto;padding:12px 16px 22px;
      display:grid; gap:12px;
      grid-template-columns: 1.1fr .9fr;
    }
    @media (max-width: 1080px){ .wrap{grid-template-columns:1fr} }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:var(--radius);
      box-shadow: 0 12px 35px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .hd{
      padding:12px; display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background: rgba(255,255,255,.03);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .hd b{font-size:13px}
    .bd{padding:12px}

    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row + .row{margin-top:10px}
    .sp{flex:1}

    button, select, input[type="text"], input[type="number"]{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      color:var(--text);
      background: rgba(255,255,255,.06);
      padding:9px 10px;
      border-radius:12px;
      font-size:13px;
      transition:.15s transform, .15s background, .15s border-color;
    }
    button{cursor:pointer}
    button:hover{transform: translateY(-1px); background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18)}
    button.primary{background: rgba(106,166,255,.18); border-color: rgba(106,166,255,.35)}
    button.ok{background: rgba(119,242,180,.12); border-color: rgba(119,242,180,.28)}
    button.danger{background: rgba(255,92,92,.12); border-color: rgba(255,92,92,.28)}
    button.ghost{background: transparent}

    .hint{color:var(--muted); font-size:12px; line-height:1.35}
    .mono{font-family:var(--mono)}
    .kbd{
      font-family:var(--mono); font-size:11px;
      padding:2px 6px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color:rgba(232,238,246,.9);
    }
    .pill{
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color:var(--muted); font-size:12px;
    }

    .err, .okbox{
      margin-top:10px; padding:10px;
      border-radius:12px; font-size:12px; display:none;
    }
    .err{border:1px solid rgba(255,92,92,.35); background: rgba(255,92,92,.10); color:#ffd1d1;}
    .okbox{border:1px solid rgba(119,242,180,.30); background: rgba(119,242,180,.08); color:#d9ffef;}

    table{
      width:100%;
      border-collapse:separate; border-spacing:0;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px; overflow:hidden;
      background: rgba(0,0,0,.15);
    }
    thead th{
      text-align:left; padding:10px; font-size:12px; color:var(--muted);
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.03);
      white-space:nowrap;
    }
    tbody td{padding:0; border-bottom:1px solid rgba(255,255,255,.06)}
    tbody tr:last-child td{border-bottom:none}
    input.cell{
      width:100%; border:none; outline:none;
      padding:10px; font-size:13px; color:var(--text);
      background: transparent;
    }
    input.cell::placeholder{color: rgba(168,179,194,.55)}
    td.action{width:60px; text-align:center}

    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
    @media (max-width: 1080px){ .grid2{grid-template-columns:1fr} }

    canvas{
      width:100%; height:620px;
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      display:block;
      cursor: crosshair;
    }

    .legend{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      color:var(--muted); font-size:12px; margin-top:8px;
    }
    .legend .item{
      display:flex; gap:8px; align-items:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      cursor:pointer;
      user-select:none;
    }
    .legend .item.off{opacity:.45; filter:saturate(.6)}
    .dot{width:10px;height:10px;border-radius:999px;display:inline-block}

    .tooltip{
      position: fixed;
      z-index: 10;
      pointer-events:none;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(10,14,22,.92);
      color: rgba(232,238,246,.95);
      font-size:12px;
      box-shadow: 0 18px 40px rgba(0,0,0,.45);
      display:none;
      max-width: 380px;
    }
    .tooltip .t{font-weight:600;margin-bottom:6px}
    .tooltip .kv{display:flex; gap:8px; justify-content:space-between}
    .tooltip .k{color: rgba(168,179,194,.9)}
    .tooltip .v{font-family:var(--mono)}
    .small{font-size:11px;color:rgba(168,179,194,.9)}

    .box{
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.14);
      padding:10px;
    }
    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    @media (max-width: 520px){ .stats{grid-template-columns:1fr} }
    .statItem{
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:10px;
      background: rgba(255,255,255,.02);
    }
    .statTitle{display:flex;align-items:center;gap:8px;color:rgba(232,238,246,.9);font-size:12px;margin-bottom:6px}
    .kvline{display:flex;justify-content:space-between;gap:10px;color:rgba(168,179,194,.92);font-size:12px}
    .kvline .v{font-family:var(--mono);color:rgba(232,238,246,.92)}
  </style>
</head>
<body>
<header>
  <h1>Gráfico ULTRA (Tech) — 1 arquivo</h1>
  <p class="sub">
    • Colar Excel/Sheets: <span class="kbd">Ctrl</span>+<span class="kbd">V</span> na tabela • Undo/Redo: <span class="kbd">Ctrl</span>+<span class="kbd">Z</span> / <span class="kbd">Ctrl</span>+<span class="kbd">Y</span><br/>
    • Gerar: <span class="kbd">Ctrl</span>+<span class="kbd">Enter</span> • Zoom: roda (<span class="kbd">Shift</span>=Y) • Pan: arrastar
  </p>
</header>

<div class="wrap">

  <!-- DADOS/CONFIG -->
  <section class="card">
    <div class="hd">
      <b>1) Dados e Config (Ultra)</b>
      <div class="row" style="margin:0">
        <button id="btnAddRow">+ Linha</button>
        <button id="btnAddSeries">+ Série Y</button>
        <button class="ok" id="btnExample">Exemplo</button>
        <button class="danger" id="btnClear">Limpar</button>
      </div>
    </div>

    <div class="bd">
      <div class="grid2">
        <div class="row">
          <span class="pill">X: Auto / Num / Texto / Data-Hora</span>
          <span class="pill">Y: Log opcional</span>
          <span class="pill">Suavização (MA)</span>
        </div>
        <div class="row" style="justify-content:flex-end">
          <label class="hint">Tipo de X</label>
          <select id="xMode">
            <option value="auto">Auto</option>
            <option value="numeric">Numérico (escala)</option>
            <option value="category">Texto (categorias)</option>
            <option value="datetime">Data/Hora</option>
          </select>
          <label class="hint">Ordenar X</label>
          <select id="sortX">
            <option value="auto">Auto</option>
            <option value="no">Não</option>
            <option value="yes">Sim</option>
          </select>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label class="hint">Título</label>
          <input id="title" type="text" value="Gráfico: Y por X" style="min-width:260px; flex:1" />
        </div>
        <div class="row">
          <label class="hint">Eixo X</label>
          <input id="xLabel" type="text" value="X" style="min-width:160px; flex:1" />
          <label class="hint">Eixo Y</label>
          <input id="yLabel" type="text" value="Y" style="min-width:160px; flex:1" />
        </div>
      </div>

      <div class="grid2" style="margin-top:10px">
        <div class="row">
          <label class="hint"><input id="chkLogY" type="checkbox" /> Y em escala log (log10)</label>
          <label class="hint"><input id="chkMA" type="checkbox" /> Suavizar (Moving Average)</label>
          <label class="hint">Janela</label>
          <input id="maWindow" type="number" min="2" max="99" step="1" value="5" style="width:110px" />
        </div>
        <div class="row" style="justify-content:flex-end">
          <button id="btnPlot" class="primary">Gerar gráfico</button>
          <button id="btnResetView">Reset zoom/pan</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnCopyPNG">Copiar PNG</button>
        <button id="btnSVG">Exportar SVG</button>
        <span class="sp"></span>
        <button id="btnSaveProject">Salvar Projeto (JSON)</button>
        <input id="fileProject" type="file" accept=".json,application/json" style="display:none">
        <button id="btnLoadProject">Carregar Projeto</button>
      </div>

      <div style="height:10px"></div>

      <table id="grid">
        <thead>
          <tr id="theadRow">
            <th style="width:28%">X</th>
            <th style="width:22%">Y1</th>
            <th style="width:60px; text-align:center">Rem</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>

      <div id="msgOk" class="okbox"></div>
      <div id="msgErr" class="err"></div>

      <div class="box" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <b style="font-size:13px">Estatísticas por série</b>
          <span class="hint">Atualiza quando você gera o gráfico</span>
        </div>
        <div id="statsPanel" class="stats" style="margin-top:10px"></div>
      </div>

      <div class="box" style="margin-top:12px">
        <div class="row" style="justify-content:space-between">
          <b style="font-size:13px">Estilo das Séries</b>
          <span class="hint">Clique para editar</span>
        </div>
        <div id="seriesPanel" class="hint" style="margin-top:10px">Gere um gráfico para editar estilos.</div>
      </div>

      <div class="hint" style="margin-top:10px">
        • Data/Hora: aceita <span class="mono">2026-01-12</span>, <span class="mono">12/01/2026</span>, <span class="mono">12/01/2026 14:30</span>.<br/>
        • LogY exige Y &gt; 0.
      </div>
    </div>
  </section>

  <!-- GRAFICO -->
  <section class="card">
    <div class="hd">
      <b>2) Gráfico</b>
      <div class="row" style="margin:0">
        <span class="pill">Legenda: clique para ocultar</span>
      </div>
    </div>
    <div class="bd">
      <canvas id="cv"></canvas>
      <div id="legend" class="legend"></div>
      <div class="hint" style="margin-top:10px">
        Tooltip mostra ponto mais próximo. (X numérico/data usa snap por X)
      </div>
    </div>
  </section>

</div>

<div id="tooltip" class="tooltip"></div>

<script>
/* ============================
   Estado / Constantes
============================ */
const palette = [
  "rgba(106,166,255,1)",
  "rgba(119,242,180,1)",
  "rgba(255,204,102,1)",
  "rgba(255,92,92,1)",
  "rgba(186,143,255,1)",
  "rgba(94,234,212,1)",
  "rgba(255,120,200,1)",
  "rgba(180,255,120,1)",
];

const state = {
  seriesCount: 1,
  rows: 14,
  view: { zoomX: 1, zoomY: 1, panX: 0, panY: 0 },
  lastPlot: null,
  styles: [],
  visible: [],
  selectedSeries: 0,

  undo: [],
  redo: [],
  undoMax: 40,
};

const LS_KEY = "app_grafico_ultra_autosave_v1";

/* ============================
   DOM
============================ */
const $ = (s) => document.querySelector(s);
const tbody = $("#tbody");
const theadRow = $("#theadRow");
const legendBox = $("#legend");
const seriesPanel = $("#seriesPanel");
const statsPanel = $("#statsPanel");
const msgErr = $("#msgErr");
const msgOk = $("#msgOk");
const tooltip = $("#tooltip");
const cv = $("#cv");
const ctx = cv.getContext("2d");

/* ============================
   Helpers
============================ */
function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function showErr(msg){
  msgOk.style.display="none"; msgOk.textContent="";
  msgErr.style.display="block"; msgErr.textContent=msg;
}
function showOk(msg){
  msgErr.style.display="none"; msgErr.textContent="";
  msgOk.style.display="block"; msgOk.textContent=msg;
}
function clearMsgs(){
  msgErr.style.display="none"; msgErr.textContent="";
  msgOk.style.display="none"; msgOk.textContent="";
}

function parseNumberBR(v){
  if (v == null) return NaN;
  v = String(v).trim();
  if (!v) return NaN;
  v = v.replace(/\s+/g,"");
  if (v.includes(",")) v = v.replace(/\./g,"").replace(",",".");
  const n = Number(v);
  return Number.isFinite(n) ? n : NaN;
}
function fmt(n, d=6){
  if (!Number.isFinite(n)) return "NaN";
  const s = n.toFixed(d);
  return s.replace(/\.?0+$/,"");
}
function downloadText(filename, text, type="application/octet-stream"){
  const blob = new Blob([text], {type});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

/* ============================
   DateTime parsing
============================ */
function parseDateTimeToMs(s){
  if (s == null) return NaN;
  const v = String(s).trim();
  if (!v) return NaN;

  // ISO: 2026-01-12 or 2026-01-12 14:30 or 2026-01-12T14:30
  let iso = v.replace(" ", "T");
  let d = new Date(iso);
  if (!isNaN(d.getTime())) return d.getTime();

  // BR: dd/mm/yyyy or dd/mm/yyyy hh:mm
  const m = v.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if (m){
    const dd = Number(m[1]), mm = Number(m[2]), yyyy = Number(m[3]);
    const hh = Number(m[4] || 0), mi = Number(m[5] || 0), ss = Number(m[6] || 0);
    const dt = new Date(yyyy, mm-1, dd, hh, mi, ss);
    return dt.getTime();
  }

  return NaN;
}
function formatMsToLabel(ms){
  const d = new Date(ms);
  // formato curto: dd/mm hh:mm
  const dd = String(d.getDate()).padStart(2,"0");
  const mm = String(d.getMonth()+1).padStart(2,"0");
  const yyyy = d.getFullYear();
  const hh = String(d.getHours()).padStart(2,"0");
  const mi = String(d.getMinutes()).padStart(2,"0");
  // se tem hora/minuto diferente de 00:00 mostra, senão só data
  if (hh !== "00" || mi !== "00") return `${dd}/${mm}/${yyyy} ${hh}:${mi}`;
  return `${dd}/${mm}/${yyyy}`;
}

/* ============================
   Styles / Visible arrays
============================ */
function ensureStyleArrays(){
  while(state.styles.length < state.seriesCount){
    const i = state.styles.length;
    state.styles.push({
      name: "Y"+(i+1),
      color: palette[i % palette.length],
      width: 2,
      point: 4.2,
      dashed: false,
    });
  }
  while(state.visible.length < state.seriesCount) state.visible.push(true);
}

/* ============================
   Undo/Redo snapshots
============================ */
function snapshot(){
  return JSON.stringify({
    seriesCount: state.seriesCount,
    styles: state.styles,
    visible: state.visible,
    meta: {
      title: $("#title").value,
      xLabel: $("#xLabel").value,
      yLabel: $("#yLabel").value,
      xMode: $("#xMode").value,
      sortX: $("#sortX").value,
      logY: $("#chkLogY").checked,
      ma: $("#chkMA").checked,
      maWindow: $("#maWindow").value,
    },
    data: getGridMatrix(),
  });
}
function restoreSnapshot(snapStr){
  const snap = JSON.parse(snapStr);
  state.seriesCount = Math.max(1, Number(snap.seriesCount||1));
  rebuildHeader();
  clearGrid();

  state.styles = Array.isArray(snap.styles) ? snap.styles : [];
  state.visible = Array.isArray(snap.visible) ? snap.visible : [];
  ensureStyleArrays();

  $("#title").value = snap.meta?.title ?? "Gráfico: Y por X";
  $("#xLabel").value = snap.meta?.xLabel ?? "X";
  $("#yLabel").value = snap.meta?.yLabel ?? "Y";
  $("#xMode").value = snap.meta?.xMode ?? "auto";
  $("#sortX").value = snap.meta?.sortX ?? "auto";
  $("#chkLogY").checked = !!snap.meta?.logY;
  $("#chkMA").checked = !!snap.meta?.ma;
  $("#maWindow").value = String(snap.meta?.maWindow ?? "5");

  if (Array.isArray(snap.data)) setGridFromMatrix(snap.data);
}
function pushUndo(){
  state.undo.push(snapshot());
  if (state.undo.length > state.undoMax) state.undo.shift();
  state.redo = [];
}
function doUndo(){
  if (!state.undo.length) return;
  state.redo.push(snapshot());
  const snap = state.undo.pop();
  restoreSnapshot(snap);
  autosave();
  showOk("Undo.");
}
function doRedo(){
  if (!state.redo.length) return;
  state.undo.push(snapshot());
  const snap = state.redo.pop();
  restoreSnapshot(snap);
  autosave();
  showOk("Redo.");
}

/* ============================
   Grid (Tabela)
============================ */
function rebuildHeader(){
  theadRow.innerHTML = "";
  const thX = document.createElement("th");
  thX.textContent = "X";
  thX.style.width = "28%";
  theadRow.appendChild(thX);

  for(let s=1;s<=state.seriesCount;s++){
    const th = document.createElement("th");
    th.textContent = "Y" + s;
    th.style.width = (Math.max(14, Math.floor(62/state.seriesCount))) + "%";
    theadRow.appendChild(th);
  }

  const thRem = document.createElement("th");
  thRem.textContent = "Rem";
  thRem.style.width = "60px";
  thRem.style.textAlign = "center";
  theadRow.appendChild(thRem);
}
function addRow(values=null){
  const tr = document.createElement("tr");

  const tdX = document.createElement("td");
  const inX = document.createElement("input");
  inX.className = "cell";
  inX.placeholder = "Ex: 1  ou  12/01/2026";
  inX.value = values?.x ?? "";
  tdX.appendChild(inX);
  tr.appendChild(tdX);

  for(let s=1;s<=state.seriesCount;s++){
    const tdY = document.createElement("td");
    const inY = document.createElement("input");
    inY.className = "cell";
    inY.placeholder = "Ex: 10,5";
    inY.value = values?.ys?.[s-1] ?? "";
    tdY.appendChild(inY);
    tr.appendChild(tdY);
  }

  const tdA = document.createElement("td");
  tdA.className = "action";
  const btn = document.createElement("button");
  btn.className = "danger";
  btn.textContent = "X";
  btn.title = "Remover linha";
  btn.onclick = () => { pushUndo(); tr.remove(); autosave(); };
  tdA.appendChild(btn);
  tr.appendChild(tdA);

  tbody.appendChild(tr);
}
function clearGrid(){
  tbody.innerHTML = "";
  for(let i=0;i<state.rows;i++) addRow();
}
function addSeries(){
  pushUndo();
  state.seriesCount += 1;
  rebuildHeader();
  const rows = [...tbody.querySelectorAll("tr")];
  rows.forEach(tr => {
    const tdY = document.createElement("td");
    const inY = document.createElement("input");
    inY.className = "cell";
    inY.placeholder = "Ex: 10,5";
    tdY.appendChild(inY);
    tr.insertBefore(tdY, tr.lastElementChild);
  });
  ensureStyleArrays();
  autosave();
}
function getGridMatrix(){
  const rows = [...tbody.querySelectorAll("tr")];
  return rows.map(tr => [...tr.querySelectorAll("input")].map(i => i.value.trim()));
}
function setGridFromMatrix(mat){
  if (!mat.length) return;

  const needCols = Math.max(2, ...mat.map(r => r.length));
  const needSeries = Math.max(1, needCols - 1);
  while(state.seriesCount < needSeries) addSeries();

  const currentRows = tbody.querySelectorAll("tr").length;
  if (currentRows < mat.length){
    for(let i=0;i<mat.length-currentRows;i++) addRow();
  }

  const rows = [...tbody.querySelectorAll("tr")];
  for(let r=0;r<mat.length;r++){
    const inputs = [...rows[r].querySelectorAll("input")];
    for(let c=0;c<Math.min(inputs.length, mat[r].length);c++){
      inputs[c].value = mat[r][c];
    }
  }
}

/* ============================
   Paste Excel/Sheets (TSV)
============================ */
function parseClipboardTSV(text){
  const lines = text.replace(/\r/g,"").split("\n").filter(l => l.length>0);
  return lines.map(l => l.split("\t"));
}
$("#grid").addEventListener("paste", (e) => {
  const text = (e.clipboardData || window.clipboardData).getData("text");
  if (!text) return;
  const mat = parseClipboardTSV(text);
  if (mat.length && mat[0].length >= 2){
    e.preventDefault();
    pushUndo();
    setGridFromMatrix(mat);
    autosave();
    showOk("Dados colados com sucesso.");
  }
});

/* ============================
   Autosave + Project
============================ */
function getProject(){
  return {
    version: 1,
    meta: {
      title: $("#title").value,
      xLabel: $("#xLabel").value,
      yLabel: $("#yLabel").value,
      xMode: $("#xMode").value,
      sortX: $("#sortX").value,
      logY: $("#chkLogY").checked,
      ma: $("#chkMA").checked,
      maWindow: Number($("#maWindow").value),
    },
    seriesCount: state.seriesCount,
    styles: state.styles,
    visible: state.visible,
    data: getGridMatrix(),
  };
}
function loadProject(proj){
  if (!proj || typeof proj !== "object") return showErr("Projeto inválido.");
  pushUndo();

  state.seriesCount = Math.max(1, Number(proj.seriesCount || 1));
  rebuildHeader();
  clearGrid();

  state.styles = Array.isArray(proj.styles) ? proj.styles : [];
  state.visible = Array.isArray(proj.visible) ? proj.visible : [];
  ensureStyleArrays();

  $("#title").value = proj.meta?.title ?? "Gráfico: Y por X";
  $("#xLabel").value = proj.meta?.xLabel ?? "X";
  $("#yLabel").value = proj.meta?.yLabel ?? "Y";
  $("#xMode").value = proj.meta?.xMode ?? "auto";
  $("#sortX").value = proj.meta?.sortX ?? "auto";
  $("#chkLogY").checked = !!proj.meta?.logY;
  $("#chkMA").checked = !!proj.meta?.ma;
  $("#maWindow").value = String(proj.meta?.maWindow ?? 5);

  if (Array.isArray(proj.data)) setGridFromMatrix(proj.data);
  ensureStyleArrays();

  state.view = { zoomX: 1, zoomY: 1, panX: 0, panY: 0 };
  state.lastPlot = null;
  legendBox.innerHTML = "";
  seriesPanel.innerHTML = "Gere um gráfico para editar estilos.";
  statsPanel.innerHTML = "";
  tooltip.style.display="none";
  drawEmpty();
  autosave();
  showOk("Projeto carregado.");
}
function autosave(){
  try{ localStorage.setItem(LS_KEY, JSON.stringify(getProject())); }catch{}
}
function tryLoadAutosave(){
  try{
    const s = localStorage.getItem(LS_KEY);
    if (!s) return;
    loadProject(JSON.parse(s));
    showOk("Autosave carregado.");
  }catch{}
}
$("#btnSaveProject").addEventListener("click", () => {
  downloadText("projeto_grafico.json", JSON.stringify(getProject(), null, 2), "application/json;charset=utf-8");
  showOk("Projeto salvo (JSON).");
});
$("#btnLoadProject").addEventListener("click", () => $("#fileProject").click());
$("#fileProject").addEventListener("change", async (e) => {
  const file = e.target.files?.[0];
  if (!file) return;
  try{
    const text = await file.text();
    loadProject(JSON.parse(text));
  }catch{
    showErr("Não foi possível ler o JSON.");
  }
  e.target.value = "";
});

// autosave + undo em edição
let inputDebounce = null;
document.addEventListener("input", (e) => {
  const t = e.target;
  if (t && (t.matches("input") || t.matches("select"))){
    if (t.classList.contains("cell")){
      // snapshot antes de mudanças em lote (pega 1x por “rajada”)
      if (!inputDebounce) pushUndo();
      clearTimeout(inputDebounce);
      inputDebounce = setTimeout(()=>{ inputDebounce=null; }, 450);
    }
    autosave();
  }
});

/* ============================
   Dados/Validação + Moving Average
============================ */
function movingAverage(points, window){
  const w = Math.max(2, Math.floor(window));
  if (points.length < w) return points.slice();
  const out = [];
  let sum = 0;
  for(let i=0;i<points.length;i++){
    sum += points[i].y;
    if (i >= w) sum -= points[i-w].y;
    if (i >= w-1){
      out.push({...points[i], y: sum/w, _ma:true});
    }
  }
  // para alinhar visualmente, preenche início copiando os primeiros
  const prefix = points.slice(0, w-1).map(p => ({...p, y: p.y, _ma:true}));
  return prefix.concat(out);
}

function readDataFromGrid(){
  clearMsgs();
  ensureStyleArrays();

  const mat = getGridMatrix();
  const rows = mat.filter(r => r.some(v => v !== ""));
  if (rows.length < 2) return { ok:false, msg:"Insira pelo menos 2 linhas com dados." };

  let mode = $("#xMode").value; // auto|numeric|category|datetime
  const xsRaw = rows.map(r => r[0]);

  if (mode === "auto"){
    const numCount = xsRaw.map(parseNumberBR).filter(n => Number.isFinite(n)).length;
    const dtCount  = xsRaw.map(parseDateTimeToMs).filter(n => Number.isFinite(n)).length;
    if (dtCount >= Math.ceil(xsRaw.length*0.7)) mode = "datetime";
    else if (numCount >= Math.ceil(xsRaw.length*0.7)) mode = "numeric";
    else mode = "category";
  }

  const series = [];
  for(let s=0;s<state.seriesCount;s++){
    series.push({ name: state.styles[s]?.name ?? ("Y"+(s+1)), points: [] , idx:s});
  }

  const logY = $("#chkLogY").checked;

  for(let i=0;i<rows.length;i++){
    const r = rows[i];
    const xLabel = r[0] || String(i+1);
    const xNum = parseNumberBR(r[0]);
    const xMs  = parseDateTimeToMs(r[0]);

    if (mode === "numeric" && !Number.isFinite(xNum)){
      return { ok:false, msg:`Linha ${i+1}: X precisa ser numérico. Você colocou “${r[0]}”.` };
    }
    if (mode === "datetime" && !Number.isFinite(xMs)){
      return { ok:false, msg:`Linha ${i+1}: X precisa ser Data/Hora. Você colocou “${r[0]}”.` };
    }

    for(let s=0;s<state.seriesCount;s++){
      const yStr = r[1+s] ?? "";
      if (yStr === "") continue;

      const yNum = parseNumberBR(yStr);
      if (!Number.isFinite(yNum)){
        return { ok:false, msg:`Linha ${i+1}: ${"Y"+(s+1)} inválido (“${yStr}”). Use número.` };
      }
      if (logY && yNum <= 0){
        return { ok:false, msg:`LogY ligado: Linha ${i+1} em ${"Y"+(s+1)} precisa ser > 0.` };
      }

      series[s].points.push({ xLabel, xNum, xMs, y: yNum, idx: i });
    }
  }

  const anyGood = series.some(s => s.points.length >= 2);
  if (!anyGood) return { ok:false, msg:"Você precisa de pelo menos 2 pontos em alguma série Y." };

  // ordenar por X
  const sortUI = $("#sortX").value;
  const doSort = (mode !== "category") && (sortUI === "yes" || sortUI === "auto");
  if (doSort){
    series.forEach(s => s.points.sort((a,b)=>{
      const ax = (mode==="numeric") ? a.xNum : a.xMs;
      const bx = (mode==="numeric") ? b.xNum : b.xMs;
      return ax-bx;
    }));
  }

  // moving average
  const doMA = $("#chkMA").checked;
  const win = Number($("#maWindow").value || 5);
  if (doMA){
    series.forEach(s => { if (s.points.length>=2) s.points = movingAverage(s.points, win); });
  }

  return { ok:true, mode, series, logY };
}

/* ============================
   Stats
============================ */
function computeStats(points){
  const ys = points.map(p=>p.y).filter(Number.isFinite);
  const n = ys.length;
  if (!n) return null;
  const min = Math.min(...ys);
  const max = Math.max(...ys);
  const mean = ys.reduce((a,b)=>a+b,0)/n;
  const varr = ys.reduce((a,b)=>a+(b-mean)*(b-mean),0)/Math.max(1,n-1);
  const std = Math.sqrt(varr);
  return {n,min,max,mean,std};
}
function renderStats(plot){
  statsPanel.innerHTML = "";
  plot.series.forEach(s=>{
    const idx = s.idx;
    const st = state.styles[idx];
    const stat = computeStats(s.points);
    if (!stat) return;

    const el = document.createElement("div");
    el.className = "statItem";
    el.innerHTML = `
      <div class="statTitle">
        <span class="dot" style="background:${st.color}"></span>
        <b>${st.name}</b>
        <span class="sp"></span>
        <span class="hint">${state.visible[idx] ? "" : "oculta"}</span>
      </div>
      <div class="kvline"><span>n</span><span class="v">${stat.n}</span></div>
      <div class="kvline"><span>min</span><span class="v">${fmt(stat.min,6)}</span></div>
      <div class="kvline"><span>max</span><span class="v">${fmt(stat.max,6)}</span></div>
      <div class="kvline"><span>média</span><span class="v">${fmt(stat.mean,6)}</span></div>
      <div class="kvline"><span>desvio</span><span class="v">${fmt(stat.std,6)}</span></div>
    `;
    statsPanel.appendChild(el);
  });
}

/* ============================
   Chart: resize, ticks, bounds, render
============================ */
function resizeCanvasToCSS(){
  const dpr = window.devicePixelRatio || 1;
  const rect = cv.getBoundingClientRect();
  const w = Math.max(320, Math.round(rect.width));
  const h = Math.max(320, Math.round(rect.height));
  cv.width = Math.round(w * dpr);
  cv.height = Math.round(h * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  return {W:w, H:h};
}
function niceStep(range, targetTicks){
  const raw = range / Math.max(1, targetTicks);
  const pow = Math.pow(10, Math.floor(Math.log10(raw)));
  const r = raw / pow;
  let step;
  if (r < 1.5) step = 1;
  else if (r < 3.5) step = 2;
  else if (r < 7.5) step = 5;
  else step = 10;
  return step * pow;
}
function drawEmpty(){
  const {W,H} = resizeCanvasToCSS();
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle = "rgba(0,0,0,.10)";
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = "rgba(168,179,194,.85)";
  ctx.font = "14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText("Insira dados e clique em “Gerar gráfico”.", 16, 28);
}

function computeBounds(mode, series, logY){
  const ys=[];
  const xs=[];
  series.forEach(s=>{
    if (!state.visible[s.idx]) return;
    s.points.forEach(p=>{
      ys.push(p.y);
      if (mode==="numeric") xs.push(p.xNum);
      else if (mode==="datetime") xs.push(p.xMs);
    });
  });
  let yMin = Math.min(...ys), yMax = Math.max(...ys);
  if (!Number.isFinite(yMin) || !Number.isFinite(yMax)){ yMin=0; yMax=1; }

  // bounds para log: trabalha no espaço log
  if (logY){
    yMin = Math.log10(yMin);
    yMax = Math.log10(yMax);
  }
  if (yMin === yMax){ yMin -= 1; yMax += 1; }
  const yPad = (yMax-yMin)*0.08;
  yMin -= yPad; yMax += yPad;

  let xMin=0, xMax=1;
  if (mode==="numeric" || mode==="datetime"){
    xMin = Math.min(...xs); xMax = Math.max(...xs);
    if (xMin === xMax){ xMin -= 1; xMax += 1; }
    const xPad = (xMax-xMin)*0.06;
    xMin -= xPad; xMax += xPad;
  } else {
    const maxN = Math.max(...series.map(s=>s.points.length));
    xMin=0; xMax=Math.max(1, maxN-1);
  }
  return {xMin,xMax,yMin,yMax};
}

function computeViewWindow(bounds, plotW, plotH){
  const zoomX = clamp(state.view.zoomX, 0.3, 80);
  const zoomY = clamp(state.view.zoomY, 0.3, 80);

  const baseXSpan = bounds.xMax - bounds.xMin;
  const baseYSpan = bounds.yMax - bounds.yMin;

  const xSpan = baseXSpan / zoomX;
  const ySpan = baseYSpan / zoomY;

  const panXUnit = (state.view.panX / plotW) * xSpan;
  const panYUnit = (state.view.panY / plotH) * ySpan;

  const xCenter = (bounds.xMin + bounds.xMax)/2 - panXUnit;
  const yCenter = (bounds.yMin + bounds.yMax)/2 + panYUnit;

  return {
    xMin: xCenter - xSpan/2,
    xMax: xCenter + xSpan/2,
    yMin: yCenter - ySpan/2,
    yMax: yCenter + ySpan/2
  };
}

function buildLegend(plot){
  legendBox.innerHTML = "";
  plot.series.forEach(s=>{
    const idx = s.idx;
    const st = state.styles[idx];
    const item = document.createElement("div");
    item.className = "item" + (state.visible[idx] ? "" : " off");
    item.innerHTML = `<span class="dot" style="background:${st.color}"></span><span>${st.name}</span>`;
    item.addEventListener("click", ()=>{
      state.visible[idx] = !state.visible[idx];
      autosave();
      if (state.lastPlot) render();
    });
    legendBox.appendChild(item);
  });
}

function renderSeriesPanel(){
  if (!state.lastPlot){
    seriesPanel.innerHTML = "Gere um gráfico para editar estilos.";
    return;
  }
  ensureStyleArrays();

  const buttons = state.lastPlot.series.map(si=>{
    const st = state.styles[si.idx];
    const active = (state.selectedSeries === si.idx);
    return `<button class="${active ? "primary" : ""}" data-s="${si.idx}">${st.name}</button>`;
  }).join("");

  const st = state.styles[state.selectedSeries] || state.styles[0];
  seriesPanel.innerHTML = `
    <div class="row">${buttons}</div>
    <div class="row" style="margin-top:12px">
      <label class="hint">Nome</label>
      <input id="styName" type="text" value="${st.name}" style="min-width:160px;flex:1" />
      <label class="hint">Cor</label>
      <input id="styColor" type="text" value="${st.color}" style="min-width:220px;flex:1" />
    </div>
    <div class="row">
      <label class="hint">Espessura</label>
      <input id="styWidth" type="number" min="1" max="10" step="1" value="${st.width}" style="width:120px" />
      <label class="hint">Ponto</label>
      <input id="styPoint" type="number" min="0" max="12" step="0.5" value="${st.point}" style="width:120px" />
      <label class="hint"><input id="styDash" type="checkbox" ${st.dashed ? "checked":""}/> Tracejado</label>
      <span class="sp"></span>
      <span class="hint">Cor: <span class="mono">rgba()</span> ou <span class="mono">#RRGGBB</span></span>
    </div>
  `;

  seriesPanel.querySelectorAll("button[data-s]").forEach(b=>{
    b.addEventListener("click", ()=>{
      state.selectedSeries = Number(b.getAttribute("data-s"));
      renderSeriesPanel();
    });
  });

  const bind = (id, fn) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener("input", fn);
    el.addEventListener("change", fn);
  };

  bind("styName", ()=>{
    state.styles[state.selectedSeries].name = $("#styName").value.trim() || ("Y"+(state.selectedSeries+1));
    autosave(); render();
  });
  bind("styColor", ()=>{
    state.styles[state.selectedSeries].color = $("#styColor").value.trim() || palette[state.selectedSeries % palette.length];
    autosave(); render();
  });
  bind("styWidth", ()=>{
    state.styles[state.selectedSeries].width = clamp(Number($("#styWidth").value)||2, 1, 10);
    autosave(); render();
  });
  bind("styPoint", ()=>{
    state.styles[state.selectedSeries].point = clamp(Number($("#styPoint").value)||0, 0, 12);
    autosave(); render();
  });
  bind("styDash", ()=>{
    state.styles[state.selectedSeries].dashed = $("#styDash").checked;
    autosave(); render();
  });
}

function drawChart(plot){
  const {W,H} = resizeCanvasToCSS();
  ctx.clearRect(0,0,W,H);

  const padL=78, padR=18, padT=34, padB=64;
  const plotW = W-padL-padR;
  const plotH = H-padT-padB;

  ctx.fillStyle="rgba(0,0,0,.10)";
  ctx.fillRect(0,0,W,H);

  const view = computeViewWindow(plot.bounds, plotW, plotH);

  const xToPx = (x) => padL + ((x - view.xMin)/(view.xMax-view.xMin))*plotW;
  const yToPx = (y) => padT + (1 - (y - view.yMin)/(view.yMax-view.yMin))*plotH;

  // grid
  const yRange = view.yMax - view.yMin;
  const xRange = view.xMax - view.xMin;
  const yMajor = niceStep(yRange, 6);
  const yMinor = yMajor / 5;

  ctx.lineWidth=1;
  ctx.strokeStyle="rgba(255,255,255,.05)";
  for(let v = Math.floor(view.yMin/yMinor)*yMinor; v<=view.yMax; v+=yMinor){
    const py = yToPx(v);
    ctx.beginPath(); ctx.moveTo(padL,py); ctx.lineTo(padL+plotW,py); ctx.stroke();
  }
  ctx.strokeStyle="rgba(255,255,255,.10)";
  for(let v = Math.floor(view.yMin/yMajor)*yMajor; v<=view.yMax; v+=yMajor){
    const py = yToPx(v);
    ctx.beginPath(); ctx.moveTo(padL,py); ctx.lineTo(padL+plotW,py); ctx.stroke();
  }

  // axes
  ctx.strokeStyle="rgba(255,255,255,.22)";
  ctx.beginPath(); ctx.moveTo(padL,padT); ctx.lineTo(padL,padT+plotH); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(padL,padT+plotH); ctx.lineTo(padL+plotW,padT+plotH); ctx.stroke();

  // title + labels
  const title = $("#title").value.trim() || "Gráfico";
  const xLabel = $("#xLabel").value.trim() || "X";
  const yLabel = $("#yLabel").value.trim() || "Y";

  ctx.fillStyle="rgba(232,238,246,.92)";
  ctx.font="13px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(title, padL, 18);

  ctx.fillStyle="rgba(168,179,194,.9)";
  ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  ctx.fillText(xLabel, padL+plotW-ctx.measureText(xLabel).width, padT+plotH+46);

  ctx.save();
  ctx.translate(18, padT + plotH/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  // y labels
  ctx.fillStyle="rgba(168,179,194,.85)";
  ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";
  for(let v = Math.floor(view.yMin/yMajor)*yMajor; v<=view.yMax; v+=yMajor){
    const py = yToPx(v);
    let label = v.toFixed(2);
    if (plot.logY){
      // v está em log => mostrar valor real
      const real = Math.pow(10, v);
      label = fmt(real, 6);
    }
    ctx.fillText(label, 10, py+4);
  }

  // x labels
  ctx.fillStyle="rgba(168,179,194,.85)";
  ctx.font="12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial";

  if (plot.mode === "numeric" || plot.mode === "datetime"){
    const xMajor = niceStep(xRange, 7);
    const xMinor = xMajor/5;

    ctx.strokeStyle="rgba(255,255,255,.04)";
    for(let v = Math.floor(view.xMin/xMinor)*xMinor; v<=view.xMax; v+=xMinor){
      const px = xToPx(v);
      ctx.beginPath(); ctx.moveTo(px,padT); ctx.lineTo(px,padT+plotH); ctx.stroke();
    }
    ctx.strokeStyle="rgba(255,255,255,.08)";
    for(let v = Math.floor(view.xMin/xMajor)*xMajor; v<=view.xMax; v+=xMajor){
      const px = xToPx(v);
      ctx.beginPath(); ctx.moveTo(px,padT); ctx.lineTo(px,padT+plotH); ctx.stroke();
      let label = v.toFixed(2);
      if (plot.mode === "datetime") label = formatMsToLabel(v);
      ctx.save();
      ctx.translate(px, padT+plotH+18);
      ctx.rotate(-0.25);
      ctx.fillText(label.length>16 ? label.slice(0,16)+"…" : label, -10, 0);
      ctx.restore();
    }
  } else {
    const base = plot.baseCategories;
    const maxLabels = 7;
    const step = Math.max(1, Math.ceil(base.length/maxLabels));
    for(let i=0;i<base.length;i+=step){
      const px = xToPx(i);
      const label = base[i] ?? String(i+1);
      const text = label.length>12 ? label.slice(0,12)+"…" : label;
      ctx.save();
      ctx.translate(px, padT+plotH+18);
      ctx.rotate(-0.35);
      ctx.fillText(text, -10, 0);
      ctx.restore();
    }
  }

  // series
  plot.series.forEach(s=>{
    const idx = s.idx;
    if (!state.visible[idx]) return;
    const st = state.styles[idx];

    // line
    ctx.strokeStyle = st.color;
    ctx.lineWidth = st.width;
    ctx.setLineDash(st.dashed ? [8,6] : []);

    ctx.beginPath();
    s.points.forEach((p,i)=>{
      const xVal = (plot.mode==="numeric") ? p.xNum : (plot.mode==="datetime") ? p.xMs : p.idx;
      const yVal = plot.logY ? Math.log10(p.y) : p.y;
      const px = xToPx(xVal);
      const py = yToPx(yVal);
      if (i===0) ctx.moveTo(px,py);
      else ctx.lineTo(px,py);
    });
    ctx.stroke();
    ctx.setLineDash([]);

    // points
    const pr = st.point;
    if (pr > 0){
      s.points.forEach(p=>{
        const xVal = (plot.mode==="numeric") ? p.xNum : (plot.mode==="datetime") ? p.xMs : p.idx;
        const yVal = plot.logY ? Math.log10(p.y) : p.y;
        const px = xToPx(xVal);
        const py = yToPx(yVal);
        ctx.beginPath();
        ctx.fillStyle = st.color;
        ctx.arc(px, py, pr, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(0,0,0,.35)";
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }
  });

  // crosshair hover
  if (plot._hover){
    const {xPx, yPx} = plot._hover;
    ctx.strokeStyle = "rgba(232,238,246,.22)";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(xPx, padT); ctx.lineTo(xPx, padT+plotH); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(padL, yPx); ctx.lineTo(padL+plotW, yPx); ctx.stroke();

    ctx.beginPath();
    ctx.fillStyle = "rgba(232,238,246,.95)";
    ctx.arc(xPx, yPx, 5.2, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,.40)";
    ctx.stroke();
  }

  plot._render = { padL,padR,padT,padB,plotW,plotH, view, xToPx, yToPx, W, H };
}

function render(){
  if (!state.lastPlot) return drawEmpty();
  // recompute bounds with visibility
  state.lastPlot.bounds = computeBounds(state.lastPlot.mode, state.lastPlot.series, state.lastPlot.logY);
  buildLegend(state.lastPlot);
  renderSeriesPanel();
  renderStats(state.lastPlot);
  drawChart(state.lastPlot);
}

/* ============================
   Hover + Snap X
============================ */
function nearestX(plot, mx){
  const r = plot._render;
  if (!r) return null;
  const xVal = r.view.xMin + (mx - r.padL)/r.plotW * (r.view.xMax - r.view.xMin);

  let bestX=null, bestDx=Infinity;
  for(const s of plot.series){
    if (!state.visible[s.idx]) continue;
    for(const p of s.points){
      const px = (plot.mode==="numeric") ? p.xNum : p.xMs;
      const dx = Math.abs(px - xVal);
      if (dx < bestDx){ bestDx=dx; bestX=px; }
    }
  }
  return bestX;
}

function findNearestPoint(plot, mx, my){
  const r = plot._render;
  if (!r) return null;
  const inside = (mx >= r.padL && mx <= r.padL+r.plotW && my >= r.padT && my <= r.padT+r.plotH);
  if (!inside) return null;

  let snap = null;
  if (plot.mode==="numeric" || plot.mode==="datetime"){
    snap = nearestX(plot, mx);
  }

  let best=null, bestD=Infinity;
  for(const s of plot.series){
    if (!state.visible[s.idx]) continue;
    const st = state.styles[s.idx];
    for(const p of s.points){
      const xVal = (plot.mode==="numeric") ? p.xNum : (plot.mode==="datetime") ? p.xMs : p.idx;

      // se snap ativo, só pega pontos com mesmo X
      if ((plot.mode==="numeric" || plot.mode==="datetime") && Number.isFinite(snap)){
        if (Math.abs(xVal - snap) > 1e-9) continue;
      }

      const useX = (Number.isFinite(snap) ? snap : xVal);
      const yVal = plot.logY ? Math.log10(p.y) : p.y;

      const xPx = r.xToPx(useX);
      const yPx = r.yToPx(yVal);
      const dx = xPx-mx, dy=yPx-my;
      const d = Math.sqrt(dx*dx+dy*dy);
      if (d < bestD){
        bestD=d;
        best = { seriesIdx:s.idx, seriesName:st.name, color:st.color, point:p, xPx, yPx, dist:d };
      }
    }
  }
  return (best && bestD <= 24) ? best : null;
}

function showTooltip(nearest, clientX, clientY, plot){
  if (!nearest){ tooltip.style.display="none"; return; }
  const p = nearest.point;
  let xText = p.xLabel;
  if (plot.mode==="numeric") xText = fmt(p.xNum,6);
  if (plot.mode==="datetime") xText = formatMsToLabel(p.xMs);

  tooltip.innerHTML = `
    <div class="t" style="display:flex;gap:10px;align-items:center">
      <span class="dot" style="background:${nearest.color}"></span>
      <span>${nearest.seriesName}</span>
    </div>
    <div class="kv"><span class="k">X</span><span class="v">${xText}</span></div>
    <div class="kv"><span class="k">Y</span><span class="v">${fmt(p.y,6)}</span></div>
    <div class="small" style="margin-top:6px;opacity:.9">Linha idx: ${p.idx+1}${plot.logY ? " • LogY" : ""}${($("#chkMA").checked) ? " • MA" : ""}</div>
  `;
  tooltip.style.display="block";

  const pad = 14;
  const w = tooltip.offsetWidth;
  const h = tooltip.offsetHeight;

  let left = clientX + pad;
  let top = clientY + pad;
  if (left + w > window.innerWidth - 8) left = clientX - w - pad;
  if (top + h > window.innerHeight - 8) top = clientY - h - pad;

  tooltip.style.left = left + "px";
  tooltip.style.top = top + "px";
}

/* ============================
   Plot
============================ */
function plotNow(){
  const res = readDataFromGrid();
  if (!res.ok){ showErr(res.msg); return; }
  ensureStyleArrays();

  let baseCategories = [];
  if (res.mode === "category"){
    const big = res.series.reduce((a,b)=> (b.points.length>a.points.length?b:a), res.series[0]);
    baseCategories = big.points.map(p => p.xLabel);
  }

  state.lastPlot = {
    mode: res.mode,
    series: res.series,
    baseCategories,
    logY: res.logY,
    bounds: computeBounds(res.mode, res.series, res.logY),
    _hover: null,
    _render: null,
  };

  tooltip.style.display="none";
  showOk("Gráfico gerado.");
  render();
  autosave();
}

/* ============================
   Pan/Zoom
============================ */
let dragging=false;
let last={x:0,y:0};

cv.addEventListener("mousedown", (e) => {
  if (!state.lastPlot) return;
  dragging=true;
  last = {x:e.clientX, y:e.clientY};
  cv.style.cursor="grabbing";
});
window.addEventListener("mouseup", () => { dragging=false; cv.style.cursor="crosshair"; });
window.addEventListener("mousemove", (e) => {
  if (dragging && state.lastPlot){
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last = {x:e.clientX, y:e.clientY};
    state.view.panX += dx;
    state.view.panY += dy;
    state.lastPlot._hover = null;
    tooltip.style.display="none";
    render();
  }
});
cv.addEventListener("wheel", (e) => {
  if (!state.lastPlot) return;
  e.preventDefault();
  const delta = Math.sign(e.deltaY);
  const factor = (delta > 0) ? 0.9 : 1.1;
  if (e.shiftKey) state.view.zoomY *= factor;
  else state.view.zoomX *= factor;
  state.view.zoomX = clamp(state.view.zoomX, 0.3, 80);
  state.view.zoomY = clamp(state.view.zoomY, 0.3, 80);
  state.lastPlot._hover = null;
  tooltip.style.display="none";
  render();
}, {passive:false});

cv.addEventListener("mousemove", (e) => {
  if (!state.lastPlot || dragging) return;
  const rect = cv.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const nearest = findNearestPoint(state.lastPlot, mx, my);
  if (nearest){
    state.lastPlot._hover = { xPx: nearest.xPx, yPx: nearest.yPx, nearest };
    showTooltip(nearest, e.clientX, e.clientY, state.lastPlot);
  } else {
    state.lastPlot._hover = null;
    tooltip.style.display="none";
  }
  render();
});
cv.addEventListener("mouseleave", () => {
  tooltip.style.display="none";
  if (state.lastPlot){
    state.lastPlot._hover = null;
    render();
  }
});

$("#btnResetView").addEventListener("click", () => {
  state.view = { zoomX: 1, zoomY: 1, panX: 0, panY: 0 };
  tooltip.style.display="none";
  if (state.lastPlot){
    state.lastPlot._hover = null;
    render();
  }
});

/* ============================
   Export: Copy PNG + SVG
============================ */
$("#btnCopyPNG").addEventListener("click", async () => {
  if (!state.lastPlot) return showErr("Gere um gráfico primeiro.");
  if (!navigator.clipboard || !window.ClipboardItem) return showErr("Seu navegador não suporta copiar imagem. Use 'Salvar PNG'.");
  cv.toBlob(async (blob)=>{
    try{
      await navigator.clipboard.write([new ClipboardItem({"image/png": blob})]);
      showOk("PNG copiado para a área de transferência.");
    }catch{
      showErr("Falhou ao copiar. Tente em outro navegador (Chrome/Edge).");
    }
  }, "image/png");
});

function svgEscape(s){ return String(s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }

$("#btnSVG").addEventListener("click", () => {
  if (!state.lastPlot || !state.lastPlot._render) return showErr("Gere o gráfico primeiro.");
  const plot = state.lastPlot;
  const r = plot._render;

  const W = r.W, H = r.H;
  const padL=r.padL, padT=r.padT, plotW=r.plotW, plotH=r.plotH;

  // conversores SVG (usa view atual)
  const view = r.view;
  const xToPx = (x) => padL + ((x - view.xMin)/(view.xMax-view.xMin))*plotW;
  const yToPx = (y) => padT + (1 - (y - view.yMin)/(view.yMax-view.yMin))*plotH;

  const title = svgEscape($("#title").value || "Gráfico");
  const xLabel = svgEscape($("#xLabel").value || "X");
  const yLabel = svgEscape($("#yLabel").value || "Y");

  let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
  svg += `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">\n`;
  svg += `<rect x="0" y="0" width="${W}" height="${H}" fill="white"/>\n`;
  svg += `<text x="${padL}" y="18" font-size="13" font-family="Arial" fill="#111">${title}</text>\n`;
  svg += `<text x="${padL+plotW-5}" y="${padT+plotH+46}" font-size="12" text-anchor="end" font-family="Arial" fill="#444">${xLabel}</text>\n`;
  // yLabel (rotacionado)
  svg += `<text x="18" y="${padT + plotH/2}" font-size="12" font-family="Arial" fill="#444" transform="rotate(-90 18 ${padT + plotH/2})">${yLabel}</text>\n`;

  // eixos
  svg += `<line x1="${padL}" y1="${padT}" x2="${padL}" y2="${padT+plotH}" stroke="#666" stroke-width="1"/>\n`;
  svg += `<line x1="${padL}" y1="${padT+plotH}" x2="${padL+plotW}" y2="${padT+plotH}" stroke="#666" stroke-width="1"/>\n`;

  // séries
  plot.series.forEach(s=>{
    if (!state.visible[s.idx]) return;
    const st = state.styles[s.idx];
    const pts = s.points.map(p=>{
      const xVal = (plot.mode==="numeric") ? p.xNum : (plot.mode==="datetime") ? p.xMs : p.idx;
      const yVal = plot.logY ? Math.log10(p.y) : p.y;
      return [xToPx(xVal), yToPx(yVal)];
    });
    if (pts.length < 2) return;

    const d = pts.map((p,i)=> (i===0?`M ${p[0].toFixed(2)} ${p[1].toFixed(2)}`:`L ${p[0].toFixed(2)} ${p[1].toFixed(2)}`)).join(" ");
    const dash = st.dashed ? ` stroke-dasharray="8 6"` : "";
    svg += `<path d="${d}" fill="none" stroke="${st.color}" stroke-width="${st.width}"${dash}/>\n`;

    if (st.point > 0){
      pts.forEach(p=>{
        svg += `<circle cx="${p[0].toFixed(2)}" cy="${p[1].toFixed(2)}" r="${st.point}" fill="${st.color}" stroke="rgba(0,0,0,.25)" stroke-width="1"/>\n`;
      });
    }
  });

  svg += `</svg>`;
  downloadText("grafico.svg", svg, "image/svg+xml;charset=utf-8");
  showOk("SVG exportado.");
});

/* ============================
   Botões / Atalhos
============================ */
$("#btnAddRow").addEventListener("click", () => { pushUndo(); addRow(); autosave(); });
$("#btnAddSeries").addEventListener("click", () => addSeries());
$("#btnPlot").addEventListener("click", plotNow);

$("#btnClear").addEventListener("click", () => {
  pushUndo();
  clearMsgs();
  state.seriesCount = 1;
  state.styles = [];
  state.visible = [];
  state.selectedSeries = 0;
  rebuildHeader();
  clearGrid();
  ensureStyleArrays();

  state.lastPlot = null;
  state.view = { zoomX: 1, zoomY: 1, panX: 0, panY: 0 };
  legendBox.innerHTML = "";
  seriesPanel.innerHTML = "Gere um gráfico para editar estilos.";
  statsPanel.innerHTML = "";
  tooltip.style.display="none";
  drawEmpty();
  autosave();
});

$("#btnExample").addEventListener("click", () => {
  pushUndo();
  while(state.seriesCount < 2) addSeries();
  tbody.innerHTML = "";
  const ex = [
    {x:"12/01/2026 08:00", ys:["1","1.2"]},
    {x:"12/01/2026 09:00", ys:["1.4","1.7"]},
    {x:"12/01/2026 10:00", ys:["1.9","2.2"]},
    {x:"12/01/2026 11:00", ys:["2.5","2.9"]},
    {x:"12/01/2026 12:00", ys:["3.2","3.5"]},
    {x:"12/01/2026 13:00", ys:["4.1","4.4"]},
    {x:"12/01/2026 14:00", ys:["5.0","5.3"]},
    {x:"12/01/2026 15:00", ys:["6.1","6.2"]},
    {x:"12/01/2026 16:00", ys:["7.0","7.4"]},
    {x:"12/01/2026 17:00", ys:["8.2","8.7"]},
  ];
  ex.forEach(r => addRow(r));
  addRow();

  $("#title").value = "Exemplo ULTRA (Data/Hora + MA)";
  $("#xLabel").value = "Tempo";
  $("#yLabel").value = "Resposta";
  $("#xMode").value = "datetime";
  $("#sortX").value = "yes";
  $("#chkMA").checked = true;
  $("#maWindow").value = "3";
  $("#chkLogY").checked = false;

  autosave();
  plotNow();
});

document.addEventListener("keydown", (e)=>{
  const z = (e.ctrlKey || e.metaKey) && !e.shiftKey && (e.key.toLowerCase()==="z");
  const y = (e.ctrlKey || e.metaKey) && (e.key.toLowerCase()==="y");
  const enter = (e.ctrlKey || e.metaKey) && (e.key === "Enter");
  if (z){ e.preventDefault(); doUndo(); }
  if (y){ e.preventDefault(); doRedo(); }
  if (enter){ e.preventDefault(); plotNow(); }
});

/* ============================
   Start
============================ */
rebuildHeader();
clearGrid();
ensureStyleArrays();
drawEmpty();
tryLoadAutosave();

window.addEventListener("resize", () => {
  if (state.lastPlot) render();
  else drawEmpty();
});
</script>
</body>
</html>
