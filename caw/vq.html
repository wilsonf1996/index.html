<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>Viga CA ‚Äì NBR 6118 (ULS + ELS + Tor√ß√£o)</title>
  <style>
    * { box-sizing: border-box; font-family: Arial, Helvetica, sans-serif; }
    body {
      margin: 0;
      padding: 0;
      background: #020617;
      color: #e5e7eb;
    }
    .container {
      max-width: 1320px;
      margin: 20px auto;
      padding: 20px;
      background: #020617;
      border-radius: 18px;
      border: 1px solid #1f2937;
      box-shadow: 0 24px 60px rgba(0,0,0,0.9);
    }
    h1, h2, h3, h4 {
      margin-top: 0;
      font-weight: 700;
    }
    h1 {
      text-align: center;
      font-size: 26px;
      margin-bottom: 4px;
    }
    .subtitle {
      text-align: center;
      font-size: 13px;
      color: #9ca3af;
      margin-bottom: 18px;
    }
    .grid {
      display: grid;
      grid-template-columns: 1.4fr 0.6fr;
      gap: 16px;
    }
    .card {
      background: #020617;
      border-radius: 14px;
      padding: 14px;
      border: 1px solid #111827;
    }
    .card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
    }
    .card-header h2 {
      font-size: 17px;
      margin: 0;
    }
    label {
      display: block;
      font-size: 12px;
      margin-bottom: 4px;
      color: #e5e7eb;
    }
    input[type="number"], select {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 13px;
    }
    input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #22c55e;
      box-shadow: 0 0 0 1px #22c55e55;
    }
    .field { margin-bottom: 8px; }
    .units { font-size: 10px; color: #9ca3af; }
    .btn-row {
      display: flex;
      gap: 10px;
      margin-top: 16px;
      justify-content: center;
      flex-wrap: wrap;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 8px 16px;
      font-size: 13px;
      cursor: pointer;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.15s ease;
    }
    button.primary {
      background: linear-gradient(135deg,#22c55e,#16a34a);
      color: #022c22;
      box-shadow: 0 10px 26px rgba(34,197,94,0.4);
    }
    button.secondary {
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #374151;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 15px 32px rgba(0,0,0,0.6);
    }
    button:active {
      transform: translateY(0);
      box-shadow: none;
    }
    .results {
      margin-top: 18px;
      border-radius: 14px;
      background: #020617;
      border: 1px solid #111827;
      padding: 14px;
      font-size: 13px;
      line-height: 1.5;
      max-height: 650px;
      overflow-y: auto;
    }
    .results h3 {
      margin-top: 0;
      font-size: 16px;
    }
    .tag {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 11px;
      margin-left: 4px;
    }
    .tag-ok {
      background: rgba(22,163,74,0.12);
      color:#4ade80;
      border:1px solid rgba(22,163,74,0.7);
    }
    .tag-warn {
      background: rgba(234,179,8,0.12);
      color:#facc15;
      border:1px solid rgba(234,179,8,0.7);
    }
    .tag-err {
      background: rgba(239,68,68,0.12);
      color:#f87171;
      border:1px solid rgba(239,68,68,0.7);
    }
    .note {
      font-size: 11px;
      color: #9ca3af;
      margin-top: 8px;
    }
    .two-cols {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .three-cols {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .small { font-size: 11px; }
    .section-title {
      margin-top: 10px;
      margin-bottom: 4px;
      font-weight: 700;
    }
    ul {
      margin-top: 4px;
      margin-bottom: 6px;
      padding-left: 18px;
    }
    @media (max-width: 900px) {
      .grid { grid-template-columns: 1fr; }
      .three-cols { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Viga de Concreto Armado ‚Äì NBR 6118</h1>
    <div class="subtitle">
      ULS (flex√£o, flexo-compress√£o com Nsd, cisalhamento, <b>tor√ß√£o</b>) + ELS (flecha, fissura√ß√£o).<br>
      Se√ß√£o retangular, concreto normal, a√ßo passivo. Tudo em um √∫nico arquivo.
    </div>

    <div class="grid">
      <!-- Materiais & Geometria & Norma -->
      <div class="card">
        <div class="card-header">
          <h2>1. Materiais, Geometria & Par√¢metros</h2>
          <span class="small" style="color:#9ca3af;">b, h, coberta em cm; √ò em mm</span>
        </div>

        <h3 style="font-size:13px;margin-top:0;">Materiais & se√ß√£o</h3>
        <div class="two-cols">
          <div class="field">
            <label>fck (MPa)</label>
            <input type="number" id="fck" value="30" step="1">
          </div>
          <div class="field">
            <label>fyk barras (MPa)</label>
            <input type="number" id="fyk" value="500" step="10">
          </div>
          <div class="field">
            <label>Largura b (cm)</label>
            <input type="number" id="b" value="20" step="0.5">
          </div>
          <div class="field">
            <label>Altura total h (cm)</label>
            <input type="number" id="h" value="50" step="0.5">
          </div>
          <div class="field">
            <label>Cobrimento (cm)</label>
            <input type="number" id="cobertura" value="3" step="0.5">
          </div>
          <div class="field">
            <label>√ò barras tra√ß√£o/compress√£o (mm)</label>
            <input type="number" id="phi_long" value="16" step="2">
          </div>
          <div class="field">
            <label>fyk estribos (MPa)</label>
            <input type="number" id="fyk_st" value="500" step="10">
          </div>
        </div>

        <h3 style="font-size:13px;margin-top:10px;">Par√¢metros normativos / materiais</h3>
        <div class="three-cols">
          <div class="field">
            <label>Œ≥c</label>
            <input type="number" id="gamma_c" value="1.4" step="0.05">
          </div>
          <div class="field">
            <label>Œ≥s</label>
            <input type="number" id="gamma_s" value="1.15" step="0.05">
          </div>
          <div class="field">
            <label>Œ±cc</label>
            <input type="number" id="alpha_cc" value="0.85" step="0.01">
          </div>
          <div class="field">
            <label>Limite x/d</label>
            <input type="number" id="x_lim" value="0.45" step="0.01">
          </div>
          <div class="field">
            <label>Es (MPa)</label>
            <input type="number" id="Es" value="210000" step="1000">
          </div>
          <div class="field">
            <label>Limite fydw (MPa)</label>
            <input type="number" id="fydw_lim" value="435" step="5">
          </div>
        </div>

        <div class="note">
          d = h ‚àí cob ‚àí √ò/2 &nbsp; e &nbsp; d' = cob + √ò/2.<br>
          Par√¢metros ajust√°veis para acompanhar revis√µes de norma e tipos de a√ßo.
        </div>
      </div>

      <!-- Esfor√ßos, modos, cisalhamento, tor√ß√£o, ELS -->
      <div class="card">
        <div class="card-header">
          <h2>2. Esfor√ßos & Modos</h2>
        </div>

        <div class="field">
          <label>Modo de uso</label>
          <select id="modo">
            <option value="dimensionar">Dimensionar (ULS flex√£o / flexo-comp / cisalhamento / tor√ß√£o)</option>
            <option value="verificar">Verificar ULS (N-M-V-T com As, As' e s dados)</option>
          </select>
        </div>

        <h3 style="font-size:13px;margin-top:10px;">ULS ‚Äì Esfor√ßos de c√°lculo</h3>
        <div class="two-cols">
          <div class="field">
            <label>Msd (kN¬∑m) ‚Äì momento na se√ß√£o</label>
            <input type="number" id="Msd" value="150" step="1">
            <span class="units">Positivo ‚Üí tra√ß√£o na borda inferior.</span>
          </div>
          <div class="field">
            <label>Vsd (kN) ‚Äì cortante</label>
            <input type="number" id="Vsd" value="200" step="1">
          </div>
          <div class="field">
            <label>Nsd (kN) ‚Äì for√ßa normal (compress√£o +)</label>
            <input type="number" id="Nsd" value="0" step="10">
            <span class="units">Nsd &gt; 0 ‚Üí flexo-compress√£o dimensionando As/As'.</span>
          </div>
          <div class="field">
            <label>Tsd (kN¬∑m) ‚Äì tor√ß√£o de c√°lculo</label>
            <input type="number" id="Tsd" value="0" step="1">
          </div>
        </div>

        <h3 style="font-size:13px;margin-top:10px;">Cisalhamento ‚Äì estribos</h3>
        <div class="two-cols">
          <div class="field">
            <label>√ò estribo (mm)</label>
            <input type="number" id="phi_stirrup" value="6.3" step="0.1">
          </div>
          <div class="field">
            <label>N¬∫ de pernas na alma</label>
            <input type="number" id="legs" value="2" step="1">
          </div>
        </div>

        <h3 style="font-size:13px;margin-top:10px;">Modo Verificar ‚Äì armaduras informadas</h3>
        <div class="two-cols">
          <div class="field">
            <label>As,trac (cm¬≤)</label>
            <input type="number" id="As_trac_user" value="0" step="0.01">
          </div>
          <div class="field">
            <label>As' (cm¬≤)</label>
            <input type="number" id="As_comp_user" value="0" step="0.01">
          </div>
          <div class="field">
            <label>s (cm) ‚Äì espa√ßamento estribos</label>
            <input type="number" id="s_user" value="0" step="0.5">
            <span class="units">Use 0 para dimensionar automaticamente.</span>
          </div>
        </div>

        <h3 style="font-size:13px;margin-top:10px;">ELS ‚Äì flecha & fissura√ß√£o (servi√ßo)</h3>
        <div class="two-cols">
          <div class="field">
            <label>V√£o L (m) ‚Äì viga biapoiada</label>
            <input type="number" id="L" value="6" step="0.1">
          </div>
          <div class="field">
            <label>q_serv (kN/m) ‚Äì carga distribu√≠da de servi√ßo</label>
            <input type="number" id="q_serv" value="20" step="0.5">
            <span class="units">Usada para flecha e fissura√ß√£o (Mser ‚âà qL¬≤/8).</span>
          </div>
        </div>

      </div>
    </div>

    <!-- Bot√µes -->
    <div class="btn-row">
      <button class="primary" onclick="calcular()">‚öôÔ∏è Calcular</button>
      <button class="secondary" onclick="limparResultados()">üßπ Limpar</button>
    </div>

    <!-- Resultados -->
    <div class="results" id="resultados">
      <h3>Resultados aparecer√£o aqui‚Ä¶</h3>
      <div class="note">
        ULS: flex√£o, flexo-compress√£o com dimensionamento autom√°tico de As e As‚Ä≤ (N+M), cisalhamento Modelo I (NBR), verifica√ß√£o de tor√ß√£o Tsd (tens√£o de cisalhamento + intera√ß√£o V‚ÄìT).  
        ELS: flecha imediata (Branson, Eci da NBR) e fissura√ß√£o (Mser/Mcr, œÉs, wk). Tudo em viga retangular.
      </div>
    </div>
  </div>

  <script>
    function format(n, dec = 2) {
      if (isNaN(n) || !isFinite(n)) return "-";
      return n.toLocaleString("pt-BR", {
        minimumFractionDigits: dec,
        maximumFractionDigits: dec
      });
    }

    function limparResultados() {
      document.getElementById("resultados").innerHTML = `
        <h3>Resultados aparecer√£o aqui‚Ä¶</h3>
        <div class="note">
          Preencha dados de materiais, geometria, esfor√ßos e par√¢metros, depois clique em <b>Calcular</b>.
        </div>
      `;
    }

    // œÅmin tipo NBR: œÅmin ‚âà 0,15¬∑fctm/fyk
    function rhoMinFlexao(fck, fyk) {
      const fctm = 0.3 * Math.pow(fck, 2.0/3.0);
      return 0.15 * fctm / fyk;
    }

    function sugerirBarras(As_alvo_mm2) {
      const diametros = [10, 12.5, 16, 20, 22, 25, 32];
      const minBarras = 2;
      const maxBarras = 8;
      const opcoes = [];

      for (let phi of diametros) {
        const areaBarra = Math.PI * phi * phi / 4.0;
        for (let n = minBarras; n <= maxBarras; n++) {
          const As_real = n * areaBarra;
          if (As_real >= As_alvo_mm2) {
            const sobra = As_real - As_alvo_mm2;
            opcoes.push({ phi, n, As_real, sobra });
          }
        }
      }
      opcoes.sort((a, b) => a.sobra - b.sobra);
      return opcoes.slice(0, 4);
    }

    function sugerirEstribos(Asw_s_req, b_mm, phi_base, legs, s_max_mm) {
      const phis = [phi_base, 8, 10];
      const s_lista_cm = [10, 12, 15, 20, 25, 30];
      const opcoes = [];

      for (let phi of phis) {
        const Asw = legs * Math.PI * phi * phi / 4.0;
        for (let s_cm of s_lista_cm) {
          const s_mm = s_cm * 10;
          if (s_mm > s_max_mm) continue;
          const Asw_s_real = Asw / s_mm;
          if (Asw_s_real >= Asw_s_req) {
            const sobra = Asw_s_real - Asw_s_req;
            opcoes.push({ phi, s_cm, Asw_s_real, sobra });
          }
        }
      }
      opcoes.sort((a, b) => a.sobra - b.sobra);
      return opcoes.slice(0, 4);
    }

    function resolver_x_M(Msd_Nmm, b_mm, d_mm, fcd, x_lim_ratio) {
      const maxIter = 60;
      const tol = 1e-6;
      const x_max = x_lim_ratio * d_mm;
      let a = 1e-6;
      let c = x_max;
      let fa = 0.68 * fcd * b_mm * a * (d_mm - 0.4 * a) - Msd_Nmm;
      let fc = 0.68 * fcd * b_mm * c * (d_mm - 0.4 * c) - Msd_Nmm;
      if (fa * fc > 0) return null;

      let b = 0;
      for (let i = 0; i < maxIter; i++) {
        b = 0.5 * (a + c);
        const fb = 0.68 * fcd * b_mm * b * (d_mm - 0.4 * b) - Msd_Nmm;
        if (Math.abs(fb) < tol) break;
        if (fa * fb < 0) { c = b; fc = fb; } else { a = b; fa = fb; }
      }
      return b;
    }

    function resolver_x_As_NM(As_trac_mm2, As_comp_mm2, b_mm, fcd, fyd, d_mm, dLinha_mm, Nsd_N, x_lim_ratio) {
      const maxIter = 60;
      const tol = 1e-6;
      const x_max = x_lim_ratio * d_mm;
      let a = 1e-6;
      let c = x_max;

      function f(x) {
        const Cc = 0.68 * fcd * b_mm * x;
        const Cs = As_comp_mm2 * fyd;
        const T  = As_trac_mm2 * fyd;
        const Nres = Cc + Cs - T;
        return Nres - Nsd_N;
      }

      let fa = f(a);
      let fc = f(c);
      if (fa * fc > 0) return null;

      let b = 0;
      for (let i = 0; i < maxIter; i++) {
        b = 0.5 * (a + c);
        const fb = f(b);
        if (Math.abs(fb) < tol) break;
        if (fa * fb < 0) { c = b; fc = fb; } else { a = b; fa = fb; }
      }
      return b;
    }

    // Dimensionamento flexo-comp N+M: varre x e resolve As/As' pelo equil√≠brio, minimizando As_total
    function dimensionarFlexoComp(Nsd_N, Msd_Nmm, b_mm, d_mm, dLinha_mm, fcd, fyd, x_lim_mm, As_min_mm2, As_maxTotal_mm2) {
      const nSteps = 180;
      const x_min = 0.05 * d_mm;
      let best = null;

      for (let i = 0; i <= nSteps; i++) {
        const x = x_min + (x_lim_mm - x_min) * (i / nSteps);
        if (x <= 0 || x > x_lim_mm) continue;

        const Cc = 0.68 * fcd * b_mm * x;
        const yC = 0.4 * x;
        const yS = dLinha_mm;
        const yT = d_mm;

        const denom = (yT - yS);
        if (denom <= 1e-6) continue;

        const Cs = (Msd_Nmm - Cc * (yC - yT) - Nsd_N * yT) / (yT - yS);
        const T  = Cc + Cs - Nsd_N;

        if (Cs < 0 || T <= 0) continue;

        let As_c = Cs / fyd;
        let As_t = T  / fyd;
        if (As_t <= 0) continue;

        const As_total = As_t + As_c;
        if (As_total > As_maxTotal_mm2) continue;
        if (As_t < As_min_mm2) continue;

        const Cc_chk = Cc;
        const Cs_chk = As_c * fyd;
        const T_chk  = As_t * fyd;
        const N_int  = Cc_chk + Cs_chk - T_chk;
        const M_int  = Cc_chk * yC + Cs_chk * yS - T_chk * yT;

        const errN = Math.abs(N_int - Nsd_N) / Math.max(Math.abs(Nsd_N), 1e-3);
        const errM = Math.abs(M_int - Msd_Nmm) / Math.max(Math.abs(Msd_Nmm), 1e-3);
        const err = Math.max(errN, errM);

        if (err > 0.05) continue;

        if (!best || As_total < best.As_total) {
          best = {
            x_mm: x,
            As_t: As_t,
            As_c: As_c,
            As_total: As_total,
            N_int: N_int,
            M_int: M_int
          };
        }
      }
      return best;
    }

    function calcular() {
      const fck = parseFloat(document.getElementById("fck").value);
      const fyk = parseFloat(document.getElementById("fyk").value);
      const fyk_st = parseFloat(document.getElementById("fyk_st").value);
      const b_cm = parseFloat(document.getElementById("b").value);
      const h_cm = parseFloat(document.getElementById("h").value);
      const cob_cm = parseFloat(document.getElementById("cobertura").value);
      const phi_long = parseFloat(document.getElementById("phi_long").value);
      const Msd_kNm = parseFloat(document.getElementById("Msd").value);
      const Vsd_kN = parseFloat(document.getElementById("Vsd").value);
      const Nsd_kN = parseFloat(document.getElementById("Nsd").value);
      const Tsd_kNm = parseFloat(document.getElementById("Tsd").value);
      const phi_st = parseFloat(document.getElementById("phi_stirrup").value);
      const legs = parseInt(document.getElementById("legs").value, 10);

      const gamma_c = parseFloat(document.getElementById("gamma_c").value);
      const gamma_s = parseFloat(document.getElementById("gamma_s").value);
      const alpha_cc = parseFloat(document.getElementById("alpha_cc").value);
      const x_lim_input = parseFloat(document.getElementById("x_lim").value);
      const Es = parseFloat(document.getElementById("Es").value);
      const fydw_lim = parseFloat(document.getElementById("fydw_lim").value);

      const modo = document.getElementById("modo").value;
      const As_trac_user_cm2 = parseFloat(document.getElementById("As_trac_user").value);
      const As_comp_user_cm2 = parseFloat(document.getElementById("As_comp_user").value);
      const s_user_cm = parseFloat(document.getElementById("s_user").value);

      const L_m = parseFloat(document.getElementById("L").value);
      const q_serv = parseFloat(document.getElementById("q_serv").value);

      const resDiv = document.getElementById("resultados");

      if ([fck, fyk, fyk_st, b_cm, h_cm, cob_cm, phi_long, Msd_kNm, Vsd_kN,
           phi_st, legs, gamma_c, gamma_s, alpha_cc, x_lim_input, Es, fydw_lim,
           L_m, q_serv].some(v => isNaN(v) || v <= 0)) {
        resDiv.innerHTML = `
          <h3>Erro de entrada</h3>
          <p>Verifique se todos os campos principais est√£o preenchidos com valores num√©ricos positivos.</p>
        `;
        return;
      }

      const b_mm = b_cm * 10;
      const h_mm = h_cm * 10;
      const cob_mm = cob_cm * 10;
      const d_mm = h_mm - cob_mm - phi_long / 2.0;
      const dLinha_mm = cob_mm + phi_long / 2.0;

      if (d_mm <= 0 || d_mm < 2 * phi_long) {
        resDiv.innerHTML = `
          <h3>Geometria inv√°lida</h3>
          <p>d ficou muito pequeno ou negativo. Verifique h, cobrimento e di√¢metro das barras.</p>
        `;
        return;
      }

      const fcd = alpha_cc * fck / gamma_c;
      const fyd = fyk / gamma_s;
      const fydw = Math.min(fyk_st / gamma_s, fydw_lim);

      const fctm = 0.3 * Math.pow(fck, 2.0 / 3.0);
      const fctk_inf = 0.7 * fctm;
      const fctd = fctk_inf / gamma_c;

      const Msd_Nmm = Msd_kNm * 1e6;
      const Vsd_N = Vsd_kN * 1e3;
      const Nsd_N = Nsd_kN * 1e3;
      const Tsd_Nmm = Tsd_kNm * 1e6;

      const x_lim_ratio = x_lim_input;
      const x_lim_mm = x_lim_ratio * d_mm;

      const Ac_mm2 = b_mm * h_mm;
      const rho_min = rhoMinFlexao(fck, fyk);
      const As_min_mm2 = rho_min * b_mm * d_mm;
      const As_maxTotal_mm2 = 0.04 * Ac_mm2;

      let avisoNorma = "";
      if (fck < 20 || fck > 50) {
        avisoNorma += "‚Ä¢ fck fora da faixa t√≠pica de concreto normal grupo I (20‚Äì50 MPa).<br>";
      }
      if (fyk < 400 || fyk > 650) {
        avisoNorma += "‚Ä¢ fyk barras fora da faixa usual (CA-25/50/60).<br>";
      }
      if (fyk_st < 400 || fyk_st > 650) {
        avisoNorma += "‚Ä¢ fyk estribos fora da faixa usual.<br>";
      }

      // -------- FLEX√ÉO / FLEXO-COMP --------
      let x_mm = 0, x_d = 0;
      let dominio_msg = "", dominio_tag = "", tipo_armadura = "";
      let As_tracao_mm2 = 0, As_comp_mm2 = 0;
      let Mrd_adot_Nmm = 0;
      let T_N = 0, Cc_N = 0, Cs_N = 0, C_N = 0, desequil_percent = 0;
      const eps_cu = 0.0035;
      let eps_c = eps_cu, eps_s = 0, eps_s_comp = 0, eps_y = fyd / Es;
      let status_eps_s = "", status_eps_s_comp = "";
      let flexo_msg_extra = "";

      const As_trac_user_mm2 = isNaN(As_trac_user_cm2) ? 0 : As_trac_user_cm2 * 100;
      const As_comp_user_mm2 = isNaN(As_comp_user_cm2) ? 0 : As_comp_user_cm2 * 100;
      const usar_As_user = (modo === "verificar" && As_trac_user_mm2 > 0);

      if (modo === "dimensionar" && Math.abs(Nsd_N) < 1e-3) {
        // FLEX√ÉO PURA
        let x_calc = resolver_x_M(Msd_Nmm, b_mm, d_mm, fcd, x_lim_ratio);
        let usa_armadura_dupla = false;
        if (x_calc === null) {
          usa_armadura_dupla = true;
        } else {
          const x_d_temp = x_calc / d_mm;
          if (x_d_temp > x_lim_ratio) usa_armadura_dupla = true;
        }

        if (!usa_armadura_dupla) {
          x_mm = x_calc;
          x_d = x_mm / d_mm;
          const z_mm = d_mm - 0.4 * x_mm;
          As_tracao_mm2 = Msd_Nmm / (fyd * z_mm);
          if (As_tracao_mm2 < As_min_mm2) {
            As_tracao_mm2 = As_min_mm2;
            tipo_armadura = "Armadura simples dimensionada (limitada por As,m√≠n).";
          } else {
            tipo_armadura = "Armadura simples dimensionada por Msd.";
          }
          if (As_tracao_mm2 > As_maxTotal_mm2) {
            tipo_armadura += " As > 4%¬∑Ac (se√ß√£o superarmada).";
          }

          if (x_d <= 0.259) {
            dominio_msg = "Dom√≠nio 2 (a√ßo bem tracionado).";
          } else if (x_d <= 0.628) {
            dominio_msg = "Dom√≠nio 3.";
          } else {
            dominio_msg = "Dom√≠nio 4 (n√£o desej√°vel).";
          }

          if (x_d <= x_lim_ratio) {
            dominio_tag = `<span class="tag tag-ok">x/d ‚â§ ${format(x_lim_ratio,2)}</span>`;
          } else {
            dominio_tag = `<span class="tag tag-err">x/d &gt; limite adotado</span>`;
          }

          const x_eq_mm = Math.min(As_tracao_mm2 * fyd / (0.68 * fcd * b_mm), x_lim_mm);
          const z_eq_mm = d_mm - 0.4 * x_eq_mm;
          Mrd_adot_Nmm = 0.68 * fcd * b_mm * x_eq_mm * z_eq_mm;
          x_mm = x_eq_mm;
          x_d = x_mm / d_mm;

          T_N = As_tracao_mm2 * fyd;
          Cc_N = 0.68 * fcd * b_mm * x_mm;
          Cs_N = 0;
          C_N = Cc_N;
          desequil_percent = Math.abs(T_N - C_N) / Math.max((T_N + C_N)/2,1e-3) * 100;
        } else {
          const z_lim_mm = d_mm - 0.4 * x_lim_mm;
          const M1rd_Nmm = 0.68 * fcd * b_mm * x_lim_mm * z_lim_mm;
          if (Msd_Nmm <= M1rd_Nmm) {
            const x_simple = resolver_x_M(Msd_Nmm, b_mm, d_mm, fcd, x_lim_ratio);
            const z_simple = d_mm - 0.4 * x_simple;
            As_tracao_mm2 = Msd_Nmm / (fyd * z_simple);
            tipo_armadura = "Armadura simples pr√≥xima a x_lim.";
            As_comp_mm2 = 0;
            x_mm = x_simple;
            x_d = x_mm / d_mm;
            const x_eq_mm = Math.min(As_tracao_mm2 * fyd / (0.68 * fcd * b_mm), x_lim_mm);
            const z_eq_mm = d_mm - 0.4 * x_eq_mm;
            Mrd_adot_Nmm = 0.68 * fcd * b_mm * x_eq_mm * z_eq_mm;
            x_mm = x_eq_mm;
            x_d = x_mm / d_mm;
            T_N = As_tracao_mm2 * fyd;
            Cc_N = 0.68 * fcd * b_mm * x_mm;
            Cs_N = 0;
            C_N = Cc_N;
            desequil_percent = Math.abs(T_N - C_N) / Math.max((T_N + C_N)/2,1e-3) * 100;
          } else {
            const deltaM_Nmm = Msd_Nmm - M1rd_Nmm;
            const alavanca_dupla_mm = d_mm - dLinha_mm;
            const As1_mm2 = M1rd_Nmm / (fyd * z_lim_mm);
            const As2_mm2 = deltaM_Nmm / (fyd * alavanca_dupla_mm);
            As_tracao_mm2 = As1_mm2 + As2_mm2;
            As_comp_mm2 = As2_mm2;
            tipo_armadura = "Armadura dupla (flex√£o).";
            const As_total = As_tracao_mm2 + As_comp_mm2;
            if (As_total > As_maxTotal_mm2) {
              tipo_armadura += " (As + As' > 4%¬∑Ac).";
            }

            dominio_msg = "Se√ß√£o for√ßada a x = x_lim; excedente levado em a√ßo comprimido.";
            dominio_tag = `<span class="tag tag-warn">Necess√°ria armadura dupla (x = ${format(x_lim_ratio,2)}¬∑d)</span>`;

            x_mm = x_lim_mm;
            x_d = x_mm / d_mm;
            const M2rd_Nmm = As2_mm2 * fyd * (d_mm - dLinha_mm);
            Mrd_adot_Nmm = M1rd_Nmm + M2rd_Nmm;
            T_N = As_tracao_mm2 * fyd;
            Cc_N = 0.68 * fcd * b_mm * x_mm;
            Cs_N = As_comp_mm2 * fyd;
            C_N = Cc_N + Cs_N;
            desequil_percent = Math.abs(T_N - C_N) / Math.max((T_N + C_N)/2,1e-3) * 100;
          }
        }
      } else if (modo === "dimensionar" && Nsd_N > 0) {
        // FLEXO-COMP N+M dimensionando As/As'
        const best = dimensionarFlexoComp(
          Nsd_N, Msd_Nmm, b_mm, d_mm, dLinha_mm,
          fcd, fyd, x_lim_mm, As_min_mm2, As_maxTotal_mm2
        );
        if (!best) {
          resDiv.innerHTML = `
            <h3>N√£o foi poss√≠vel dimensionar flexo-compress√£o</h3>
            <p>Para (Nsd, Msd) e esta se√ß√£o, n√£o foi encontrada combina√ß√£o de As/As' com x/d ‚â§ ${format(x_lim_ratio,2)} e As_total ‚â§ 4%¬∑Ac.</p>
          `;
          return;
        }
        x_mm = best.x_mm;
        As_tracao_mm2 = best.As_t;
        As_comp_mm2 = best.As_c;
        x_d = x_mm / d_mm;
        tipo_armadura = "Armadura dupla dimensionada para flexo-compress√£o (N+M).";
        Cc_N = 0.68 * fcd * b_mm * x_mm;
        Cs_N = As_comp_mm2 * fyd;
        T_N  = As_tracao_mm2 * fyd;
        C_N  = Cc_N + Cs_N;
        desequil_percent = Math.abs(C_N - T_N - Nsd_N) / Math.max(Math.abs(Nsd_N),1e-3) * 100;

        const yC = 0.4 * x_mm;
        const yS = dLinha_mm;
        const yT = d_mm;
        const M_int = Cc_N * yC + Cs_N * yS - T_N * yT;
        Mrd_adot_Nmm = M_int;

        if (x_d <= 0.259) {
          dominio_msg = "Dom√≠nio 2 aproximado (flexo-comp).";
        } else if (x_d <= 0.628) {
          dominio_msg = "Dom√≠nio 3 aproximado (flexo-comp).";
        } else {
          dominio_msg = "Dom√≠nio 4 (n√£o desej√°vel).";
        }
        if (x_d <= x_lim_ratio) {
          dominio_tag = `<span class="tag tag-ok">x/d ‚â§ ${format(x_lim_ratio,2)}</span>`;
        } else {
          dominio_tag = `<span class="tag tag-err">x/d &gt; limite adotado</span>`;
        }
        flexo_msg_extra = "Flexo-compress√£o dimensionada por equil√≠brio N-M com bloco 0,68¬∑fcd e a√ßo a fyd.";
      } else {
        // VERIFICA√á√ÉO COM As / As'
        As_tracao_mm2 = As_trac_user_mm2;
        As_comp_mm2 = Math.max(0, As_comp_user_mm2);
        const x_calc = resolver_x_As_NM(
          As_tracao_mm2, As_comp_mm2, b_mm, fcd, fyd,
          d_mm, dLinha_mm, Nsd_N, x_lim_ratio
        );
        if (x_calc === null) {
          resDiv.innerHTML = `
            <h3>Erro na verifica√ß√£o N-M</h3>
            <p>Com Nsd, Msd e armaduras informadas (As, As'), n√£o foi poss√≠vel encontrar x com x/d ‚â§ ${format(x_lim_ratio,2)} em equil√≠brio.</p>
          `;
          return;
        }
        x_mm = x_calc;
        x_d = x_mm / d_mm;
        const Cc = 0.68 * fcd * b_mm * x_mm;
        const Cs = As_comp_mm2 * fyd;
        const T  = As_tracao_mm2 * fyd;
        Cc_N = Cc; Cs_N = Cs; T_N = T; C_N = Cc + Cs;
        const yC = 0.4 * x_mm;
        const yS = dLinha_mm;
        const yT = d_mm;
        const N_int = C_N - T_N;
        const M_int = Cc * yC + Cs * yS - T * yT;
        desequil_percent = Math.max(
          Math.abs(N_int - Nsd_N) / Math.max(Math.abs(Nsd_N),1e-3),
          Math.abs(M_int - Msd_Nmm) / Math.max(Math.abs(Msd_Nmm),1e-3)
        ) * 100;
        Mrd_adot_Nmm = M_int;
        if (x_d <= 0.259) {
          dominio_msg = "Dom√≠nio 2 (verifica√ß√£o N-M).";
        } else if (x_d <= 0.628) {
          dominio_msg = "Dom√≠nio 3 (verifica√ß√£o N-M).";
        } else {
          dominio_msg = "Dom√≠nio 4 (n√£o desej√°vel).";
        }
        if (x_d <= x_lim_ratio) {
          dominio_tag = `<span class="tag tag-ok">x/d ‚â§ ${format(x_lim_ratio,2)}</span>`;
        } else {
          dominio_tag = `<span class="tag tag-err">x/d &gt; limite adotado</span>`;
        }
        tipo_armadura = "Verifica√ß√£o com As,trac e As' informados (N-M).";
      }

      // Deforma√ß√µes ELU
      eps_c = eps_cu;
      eps_s = eps_c * (d_mm - x_mm) / x_mm;
      eps_s_comp = x_mm > dLinha_mm ? eps_c * (x_mm - dLinha_mm) / x_mm : 0;
      status_eps_s = eps_s >= eps_y ? "a√ßo tracionado escoando" : "a√ßo tracionado N√ÉO escoando";
      status_eps_s_comp = (As_comp_mm2 > 0 && eps_s_comp > 0)
        ? (eps_s_comp >= eps_y ? "a√ßo comprimido escoando" : "a√ßo comprimido N√ÉO escoando")
        : "sem a√ßo comprimido relevante";

      const rho_adot = As_tracao_mm2 / (b_mm * d_mm);
      let flex_tag = "";
      if (As_tracao_mm2 + As_comp_mm2 > As_maxTotal_mm2) {
        flex_tag = `<span class="tag tag-err">As > 4%¬∑Ac (m√°ximo normativo)</span>`;
      } else {
        flex_tag = `<span class="tag tag-ok">Taxas de armadura dentro de 4%¬∑Ac</span>`;
      }

      const FS_M = Mrd_adot_Nmm / Msd_Nmm;

      let htmlSugBarras = "";
      if (modo === "dimensionar" && Math.abs(Nsd_N) < 1e-3) {
        const sugeridas = sugerirBarras(As_tracao_mm2);
        if (sugeridas.length > 0) {
          htmlSugBarras = "<ul>";
          sugeridas.forEach(op => {
            htmlSugBarras += `
              <li>${op.n}√ò${format(op.phi,1)} ‚áí As = ${format(op.As_real,1)} mm¬≤
              (‚Üë ${format(Math.max((op.As_real / As_tracao_mm2 - 1)*100,0),1)}% acima de As,trac adotado)</li>`;
          });
          htmlSugBarras += "</ul>";
        } else {
          htmlSugBarras = `<p class="note">Nenhuma combina√ß√£o simples (2‚Äì8 barras, √ò10‚Äì√ò32) encontrada acima de As,trac adotado.</p>`;
        }
      } else {
        htmlSugBarras = `<p class="note">Flexo-comp / verifica√ß√£o: combina√ß√µes comerciais podem ser montadas a partir de As e As'.</p>`;
      }

      // -------- CISALHAMENTO ‚Äì Modelo I --------
      const alpha_v2 = 1.0 - fck / 250.0;
      const VRd2_N = 0.27 * alpha_v2 * fcd * b_mm * d_mm;
      const Vc0_N = 0.6 * fctd * b_mm * d_mm;

      const vEd_MPa = Vsd_N / (b_mm * d_mm);
      const vRd2_MPa = VRd2_N / (b_mm * d_mm);
      const FS_V = VRd2_N / Vsd_N;

      let cis_tag = "";
      let cis_msg = "";
      let Asw_s_req = null;
      let Asw_s_min = null;
      let Asw_s_dim = null;
      let s_max_mm = null;
      let Asw_stirrup_mm2 = null;
      let s_mm_calc = null;
      let s_adot_mm = null;
      let rho_w_adot = null;
      let estribo_tag = "";
      let htmlSugEstr = "";
      let shearBlock = "";

      if (Vsd_N > VRd2_N) {
        cis_tag = `<span class="tag tag-err">Vsd > VRd2 (compress√£o diagonal n√£o verificada)</span>`;
        cis_msg = "Necess√°rio aumentar se√ß√£o (bw, d) e/ou fck ou reduzir Vsd.";
        shearBlock = `
          <h4>2) Cisalhamento ‚Äì Modelo I (biela comprimida)</h4>
          ${cis_tag}
          <ul>
            <li>VRd2 ‚âà <strong>${format(VRd2_N/1e3,1)}</strong> kN (ŒΩRd2 ‚âà ${format(vRd2_MPa,3)} MPa)</li>
            <li>Vsd = <strong>${format(Vsd_kN,1)}</strong> kN (ŒΩEd ‚âà ${format(vEd_MPa,3)} MPa)</li>
            <li>FS_V = VRd2/Vsd ‚âà <strong>${format(FS_V,2)}</strong></li>
            <li>${cis_msg}</li>
          </ul>
        `;
      } else {
        let Vsw_N = 0;
        if (Vsd_N <= Vc0_N) {
          cis_tag = `<span class="tag tag-ok">Vsd ‚â§ Vc0 ‚Üí concreto resiste, usar Asw m√≠nima</span>`;
          cis_msg = "Modelo I: Vsd ‚â§ Vc0, estribos m√≠nimos de cisalhamento.";
        } else {
          cis_tag = `<span class="tag tag-warn">Vsd > Vc0 ‚Üí dimensionar estribos</span>`;
          cis_msg = "Parcela acima de Vc0 vence por estribos (Vsw = Vsd ‚àí Vc0).";
        }

        Vsw_N = Math.max(Vsd_N - Vc0_N, 0);
        const z_mm = 0.9 * d_mm;
        Asw_s_dim = Vsw_N > 0 ? Vsw_N / (z_mm * fydw) : 0;
        Asw_s_min = 0.2 * (fctm / fyk_st) * b_mm;
        Asw_s_req = Math.max(Asw_s_dim, Asw_s_min);

        const razao = Vsd_N / VRd2_N;
        if (razao <= 0.67) {
          s_max_mm = Math.min(0.6 * d_mm, 300.0);
        } else {
          s_max_mm = Math.min(0.3 * d_mm, 200.0);
        }

        Asw_stirrup_mm2 = legs * Math.PI * phi_st * phi_st / 4.0;
        let s_user_mm = (modo === "verificar" && s_user_cm > 0) ? s_user_cm * 10 : 0;
        const usar_s_user = (modo === "verificar" && s_user_mm > 0);

        if (!usar_s_user) {
          s_mm_calc = Asw_stirrup_mm2 / Asw_s_req;
          s_adot_mm = Math.min(s_mm_calc, s_max_mm);
        } else {
          s_mm_calc = Asw_stirrup_mm2 / Asw_s_req;
          s_adot_mm = s_user_mm;
        }

        rho_w_adot = Asw_stirrup_mm2 / (s_adot_mm * b_mm);

        if (!usar_s_user) {
          if (s_mm_calc <= s_max_mm + 1e-6) {
            estribo_tag = `<span class="tag tag-ok">s_calc ‚â§ s<sub>m√°x</sub></span>`;
          } else {
            estribo_tag = `<span class="tag tag-warn">s_calc &gt; s<sub>m√°x</sub>, adotado s = s<sub>m√°x</sub></span>`;
          }
        } else {
          if (s_user_mm <= s_max_mm + 1e-6 && (Asw_stirrup_mm2 / s_user_mm) >= Asw_s_req) {
            estribo_tag = `<span class="tag tag-ok">Estribo informado atende Asw/s,req e s ‚â§ s<sub>m√°x</sub></span>`;
          } else {
            estribo_tag = `<span class="tag tag-err">Estribo informado N√ÉO atende (Asw/s ou s)</span>`;
          }
        }

        const estr_sug = usar_s_user ? [] : sugerirEstribos(Asw_s_req, b_mm, phi_st, legs, s_max_mm);
        if (!usar_s_user) {
          if (estr_sug.length > 0) {
            htmlSugEstr = "<ul>";
            estr_sug.forEach(op => {
              htmlSugEstr += `
                <li>√ò${format(op.phi,1)} c/${format(op.s_cm,0)} cm ‚Üí Asw/s = ${format(op.Asw_s_real,3)} mm¬≤/mm
                (‚Üë ${format((op.Asw_s_real / Asw_s_req - 1)*100,1)}% acima do requerido)</li>`;
            });
            htmlSugEstr += "</ul>";
          } else {
            htmlSugEstr = `<p class="note">Nenhuma combina√ß√£o simples (√ò${phi_st}, 8, 10; 10‚Äì30 cm) encontrada acima de Asw/s,req respeitando s<sub>m√°x</sub>.</p>`;
          }
        } else {
          htmlSugEstr = `<p class="note">Modo verifica√ß√£o: estribos s√£o entrada do usu√°rio, o app s√≥ verifica.</p>`;
        }

        shearBlock = `
          <h4>2) Cisalhamento ‚Äì Modelo I (NBR)</h4>
          ${cis_tag}
          <ul>
            <li>VRd2 ‚âà <strong>${format(VRd2_N/1e3,1)}</strong> kN (ŒΩRd2 ‚âà ${format(vRd2_MPa,3)} MPa)</li>
            <li>Vsd = <strong>${format(Vsd_kN,1)}</strong> kN (ŒΩEd ‚âà ${format(vEd_MPa,3)} MPa)</li>
            <li>FS_V = VRd2/Vsd ‚âà <strong>${format(FS_V,2)}</strong></li>
            <li>Vc0 ‚âà <strong>${format(Vc0_N/1e3,1)}</strong> kN</li>
            <li>${cis_msg}</li>
            <li>Asw/s,m√≠n ‚âà <strong>${format(Asw_s_min,3)}</strong> mm¬≤/mm</li>
            <li>Asw/s,dim ‚âà <strong>${format(Asw_s_dim,3)}</strong> mm¬≤/mm</li>
            <li>Asw/s,req = <strong>${format(Asw_s_req,3)}</strong> mm¬≤/mm</li>
          </ul>

          <p class="section-title">Estribo considerado</p>
          ${estribo_tag}
          <ul>
            <li>Asw (por estribo) = <strong>${format(Asw_stirrup_mm2,2)}</strong> mm¬≤ (√ò${format(phi_st,1)} mm, ${legs} pernas)</li>
            <li>s<sub>m√°x</sub> = <strong>${format(s_max_mm/10)}</strong> cm</li>
            <li>s_calc = <strong>${format(s_mm_calc/10)}</strong> cm</li>
            <li>s<sub>adot</sub> = <strong>${format(s_adot_mm/10)}</strong> cm</li>
            <li>œÅw adotada = <strong>${format(rho_w_adot*1000,3)}</strong> ‚Ä∞</li>
          </ul>

          <p class="section-title">Sugest√£o de estribos comerciais</p>
          ${htmlSugEstr}
        `;
      }

      // -------- TOR√á√ÉO ‚Äì verifica√ß√£o el√°stica + intera√ß√£o V‚ÄìT --------
      let torsionBlock = "";
      if (Tsd_kNm > 0) {
        // Aproxima viga como se√ß√£o retangular maci√ßa ‚Üí momento polar J para ret√¢ngulo (f√≥rmula cl√°ssica)
        // J ‚âà b*h^3 * (1/3 - 0.21 b/h (1 - b^4/(12 h^4))) com b ‚â§ h, aqui fazemos com b‚â§h ordenado
        let b_t = b_mm / 1000; // m
        let h_t = h_mm / 1000; // m
        if (b_t > h_t) { const tmp = b_t; b_t = h_t; h_t = tmp; }

        const beta = b_t / h_t;
        const J_m4 = b_t * Math.pow(h_t,3) * (1/3 - 0.21*beta*(1 - Math.pow(beta,4)/12));
        const tau_t_MPa = (Tsd_kNm * 1e6 * (h_t/2)) / (J_m4) / 1e6; // tens√£o de cisalhamento m√°x

        // Limite de tens√£o de cisalhamento por tor√ß√£o: comparar com fra√ß√£o de fctd ou vRd2 (crit√©rio conservador)
        const tau_lim_MPa = 0.5 * fctd; // crit√©rio el√°stico baseado em tra√ß√£o do concreto
        const FS_tau = tau_lim_MPa / tau_t_MPa;

        // Intera√ß√£o V‚ÄìT por tens√£o de cisalhamento equivalente
        const tau_v_MPa = vEd_MPa; // cisalhamento
        const tau_eq_MPa = Math.sqrt(tau_v_MPa*tau_v_MPa + tau_t_MPa*tau_t_MPa);
        const tau_eq_lim_MPa = vRd2_MPa;
        const FS_tau_eq = tau_eq_lim_MPa / tau_eq_MPa;

        let tors_tag = "";
        if (tau_t_MPa <= tau_lim_MPa && tau_eq_MPa <= tau_eq_lim_MPa) {
          tors_tag = `<span class="tag tag-ok">Tor√ß√£o OK (œÑ_t e œÑ_eq ‚â§ limites)</span>`;
        } else if (tau_eq_MPa > tau_eq_lim_MPa) {
          tors_tag = `<span class="tag tag-err">Tor√ß√£o + cisalhamento excedem ŒΩRd2 (œÑ_eq &gt; œÑ_lim)</span>`;
        } else {
          tors_tag = `<span class="tag tag-warn">Tor√ß√£o elevada ‚Äì verificar detalhamento/armadura de tor√ß√£o</span>`;
        }

        torsionBlock = `
          <h4>2.b) Verifica√ß√£o de Tor√ß√£o (Tsd)</h4>
          ${tors_tag}
          <ul>
            <li>Tsd = <strong>${format(Tsd_kNm,1)}</strong> kN¬∑m</li>
            <li>œÑ_t,Ed ‚âà <strong>${format(tau_t_MPa,3)}</strong> MPa (tor√ß√£o pura, teoria el√°stica)</li>
            <li>Limite adotado œÑ_t,Rd ‚âà <strong>${format(tau_lim_MPa,3)}</strong> MPa (fun√ß√£o de fctd)</li>
            <li>FS_œÑ = œÑ_t,Rd / œÑ_t,Ed ‚âà <strong>${format(FS_tau,2)}</strong></li>
            <li>œÑ_v,Ed (cisalhamento) ‚âà <strong>${format(tau_v_MPa,3)}</strong> MPa</li>
            <li>œÑ_eq = ‚àö(œÑ_v¬≤ + œÑ_t¬≤) ‚âà <strong>${format(tau_eq_MPa,3)}</strong> MPa</li>
            <li>œÑ_eq,lim ‚âà ŒΩRd2 ‚âà <strong>${format(tau_eq_lim_MPa,3)}</strong> MPa ‚áí FS_œÑ,eq ‚âà <strong>${format(FS_tau_eq,2)}</strong></li>
          </ul>
          <p class="note">
            Tor√ß√£o verificada por teoria el√°stica cl√°ssica (se√ß√£o retangular maci√ßa) e intera√ß√£o V‚ÄìT via tens√£o de cisalhamento equivalente.
            Para dimensionar armaduras espec√≠ficas de tor√ß√£o (estribos e barras longitudinais de tor√ß√£o),
            ainda √© necess√°rio aplicar os modelos detalhados da NBR com a√ßos de tor√ß√£o espec√≠ficos.
          </p>
        `;
      }

      // -------- ELS ‚Äì Fissura√ß√£o / Flecha --------
      const L_mm = L_m * 1000;
      const q_Npm = q_serv * 1000;

      const Eci = 5600 * Math.sqrt(fck);
      const Ec = 0.85 * Eci;

      const b_m = b_mm / 1000;
      const h_m = h_mm / 1000;

      const Ig = b_m * Math.pow(h_m,3) / 12.0;
      const W = Ig / (h_m/2);
      const Mcr_ser_Nm = fctm * 1e6 * W;
      const Mser_Nm = q_Npm * Math.pow(L_m,2) / 8.0;

      let fiss_tag = "";
      let fiss_msg = "";
      let wk_mm = 0;

      if (Mser_Nm <= Mcr_ser_Nm) {
        fiss_tag = `<span class="tag tag-ok">Mser ‚â§ Mcr ‚Üí se√ß√£o pouco fissurada</span>`;
        fiss_msg = "Momento de servi√ßo abaixo do momento de fissura√ß√£o.";
      } else {
        fiss_tag = `<span class="tag tag-warn">Mser > Mcr ‚Üí se√ß√£o fissurada</span>`;
        const nE = Es / Ec;
        const As_m2 = As_tracao_mm2 / 1e6;
        const d_m = d_mm / 1000;
        const x_m = x_mm / 1000;
        const Ic_conc = b_m * Math.pow(x_m,3) / 3;
        const y_s = d_m - x_m;
        const Ic_steel = nE * As_m2 * y_s * y_s;
        const Icr = Ic_conc + Ic_steel;
        const ratio = Math.min(Mcr_ser_Nm / Mser_Nm, 1.0);
        const Ief = Math.pow(ratio,3) * Ig + (1 - Math.pow(ratio,3)) * Icr;

        const sigma_s_MPa = (Mser_Nm * (d_m - x_m) * nE) / Ief / 1e6;
        const eps_sm = sigma_s_MPa / Es;
        const srm_mm = 60;
        wk_mm = eps_sm * srm_mm;

        fiss_msg = `œÉs,ser ‚âà ${format(sigma_s_MPa,2)} MPa, wk ‚âà ${format(wk_mm,3)} mm (modelo tipo Branson/fib).`;
      }

      const nE2 = Es / Ec;
      const As_m2_2 = As_tracao_mm2 / 1e6;
      const d_m2 = d_mm / 1000;
      const x_m2 = x_mm / 1000;
      const Ic_conc2 = b_m * Math.pow(x_m2,3) / 3;
      const y_s2 = d_m2 - x_m2;
      const Ic_steel2 = nE2 * As_m2_2 * y_s2 * y_s2;
      const Icr2 = Ic_conc2 + Ic_steel2;
      const ratio_els = Math.min(Mcr_ser_Nm / Mser_Nm, 1.0);
      const Ief_serv = Math.pow(ratio_els,3) * Ig + (1 - Math.pow(ratio_els,3)) * Icr2;

      const delta_m = (5 * q_Npm * Math.pow(L_m,4)) / (384 * Ec * 1e6 * Ief_serv);
      const delta_mm = delta_m * 1000;
      const limite_L250 = L_m * 1000 / 250;

      let flecha_tag = "";
      if (delta_mm <= limite_L250) {
        flecha_tag = `<span class="tag tag-ok">Œ¥ ‚â§ L/250 (flecha imediata OK)</span>`;
      } else {
        flecha_tag = `<span class="tag tag-warn">Œ¥ &gt; L/250 (verificar ELS-def com mais refinamento)</span>`;
      }

      resDiv.innerHTML = `
        <h3>Resumo dos resultados</h3>

        ${avisoNorma ? `<p class="note"><b>Aviso de validade:</b><br>${avisoNorma}</p>` : ""}

        <p><strong>Dados b√°sicos:</strong></p>
        <ul>
          <li>Modo: <strong>${modo === "dimensionar" ? "Dimensionar" : "Verificar N-M-V-T"}</strong></li>
          <li>fck = <strong>${format(fck,0)}</strong> MPa, fyk barras = <strong>${format(fyk,0)}</strong> MPa, fyk estribos = <strong>${format(fyk_st,0)}</strong> MPa</li>
          <li>b = <strong>${format(b_cm)}</strong> cm, h = <strong>${format(h_cm)}</strong> cm, cob = <strong>${format(cob_cm)}</strong> cm</li>
          <li>√ò flex√£o = <strong>${format(phi_long)}</strong> mm, √ò estribo = <strong>${format(phi_st,1)}</strong> mm, ${legs} pernas</li>
          <li>Msd = <strong>${format(Msd_kNm)}</strong> kN¬∑m, Vsd = <strong>${format(Vsd_kN)}</strong> kN, Nsd = <strong>${format(Nsd_kN,1)}</strong> kN, Tsd = <strong>${format(Tsd_kNm,1)}</strong> kN¬∑m</li>
        </ul>

        <p><strong>Par√¢metros adotados:</strong></p>
        <ul>
          <li>Œ≥c = <strong>${format(gamma_c,2)}</strong>, Œ≥s = <strong>${format(gamma_s,2)}</strong>, Œ±cc = <strong>${format(alpha_cc,2)}</strong></li>
          <li>Limite x/d = <strong>${format(x_lim_ratio,2)}</strong>, Es = <strong>${format(Es,0)}</strong> MPa, fydw,lim = <strong>${format(fydw_lim,0)}</strong> MPa</li>
        </ul>

        <p><strong>Geometria √∫til e resist√™ncias:</strong></p>
        <ul>
          <li>d = <strong>${format(d_mm/10)}</strong> cm, d' = <strong>${format(dLinha_mm/10)}</strong> cm</li>
          <li>fcd = <strong>${format(fcd,2)}</strong> MPa, fyd = <strong>${format(fyd,2)}</strong> MPa, fydw = <strong>${format(fydw,2)}</strong> MPa</li>
          <li>fctm ‚âà <strong>${format(fctm,2)}</strong> MPa, fctd ‚âà <strong>${format(fctd,2)}</strong> MPa</li>
        </ul>

        <h4>1) ULS ‚Äì Flex√£o / Flexo-Compress√£o</h4>
        ${flex_tag} ${dominio_tag}
        <ul>
          <li>Tipo de armadura / an√°lise: ${tipo_armadura}</li>
          <li>x = <strong>${format(x_mm/10)}</strong> cm (=${format(x_mm)} mm) ‚áí x/d = <strong>${format(x_d,3)}</strong></li>
          <li>As,trac = <strong>${format(As_tracao_mm2)}</strong> mm¬≤ = <strong>${format(As_tracao_mm2/100)}</strong> cm¬≤</li>
          <li>As' (compress√£o) = <strong>${format(As_comp_mm2)}</strong> mm¬≤ = <strong>${format(As_comp_mm2/100)}</strong> cm¬≤</li>
          <li>œÅm√≠n ‚âà <strong>${format(rho_min*100,3)}</strong> % ‚áí As,m√≠n ‚âà <strong>${format(As_min_mm2)}</strong> mm¬≤</li>
          <li>(As + As')m√°x = 4%¬∑Ac ‚áí <strong>${format(As_maxTotal_mm2)}</strong> mm¬≤</li>
          <li>œÅ(trac) adotada ‚âà <strong>${format(rho_adot*1000,3)}</strong> ‚Ä∞</li>
          <li>Mrd (N-M) ‚âà <strong>${format(Mrd_adot_Nmm/1e6,2)}</strong> kN¬∑m ‚áí FS_M = Mrd/Msd ‚âà <strong>${format(FS_M,2)}</strong></li>
        </ul>
        <p class="note">
          Dom√≠nio aproximado: ${dominio_msg}<br>
          ${flexo_msg_extra}
        </p>

        <p class="section-title">Deforma√ß√µes no ELU (Œµc = 3,5‚Ä∞)</p>
        <ul>
          <li>Œµc topo ‚âà <strong>${format(eps_c*1000,3)}</strong> ‚Ä∞</li>
          <li>Œµs tra√ß√£o ‚âà <strong>${format(eps_s*1000,3)}</strong> ‚Ä∞, Œµy ‚âà <strong>${format(eps_y*1000,3)}</strong> ‚Ä∞ ‚Üí ${status_eps_s}</li>
          <li>Œµs' compress√£o ‚âà <strong>${format(eps_s_comp*1000,3)}</strong> ‚Ä∞ ‚Üí ${status_eps_s_comp}</li>
        </ul>

        <p class="section-title">Equil√≠brio interno N-M</p>
        <ul>
          <li>T = As,trac¬∑fyd ‚âà <strong>${format(T_N/1e3,2)}</strong> kN</li>
          <li>Cc ‚âà <strong>${format(Cc_N/1e3,2)}</strong> kN, Cs ‚âà <strong>${format(Cs_N/1e3,2)}</strong> kN ‚áí C = <strong>${format(C_N/1e3,2)}</strong> kN</li>
          <li>Erro relativo N/M ‚âà <strong>${format(desequil_percent,2)}</strong> %</li>
        </ul>

        <p class="section-title">Sugest√£o de barras</p>
        ${htmlSugBarras}

        <hr style="border-color:#111827; margin:10px 0;">

        ${shearBlock}
        ${torsionBlock}

        <hr style="border-color:#111827; margin:10px 0;">

        <h4>3) ELS ‚Äì Fissura√ß√£o e Flecha (viga biapoiada com q_serv)</h4>
        ${fiss_tag}
        <ul>
          <li>L = <strong>${format(L_m,2)}</strong> m, q_serv = <strong>${format(q_serv,2)}</strong> kN/m</li>
          <li>Mser ‚âà qL¬≤/8 ‚âà <strong>${format(Mser_Nm/1e6,2)}</strong> kN¬∑m</li>
          <li>Mcr ‚âà fctm¬∑W ‚âà <strong>${format(Mcr_ser_Nm/1e6,2)}</strong> kN¬∑m</li>
          <li>${fiss_msg}</li>
        </ul>

        ${flecha_tag}
        <ul>
          <li>Ig ‚âà <strong>${format(Ig*1e12,2)}</strong> cm‚Å¥</li>
          <li>Ief,serv ‚âà <strong>${format(Ief_serv*1e12,2)}</strong> cm‚Å¥ (Branson)</li>
          <li>Eci ‚âà <strong>${format(Eci,0)}</strong> MPa, Ec ‚âà <strong>${format(Ec,0)}</strong> MPa</li>
          <li>Œ¥ (flecha imediata) ‚âà <strong>${format(delta_mm,2)}</strong> mm</li>
          <li>Limite L/250 ‚âà <strong>${format(limite_L250,2)}</strong> mm</li>
        </ul>

        <p class="note">
          Este arquivo √∫nico j√° tem um n√∫cleo de c√°lculo bem robusto para viga/pilar retangular:
          ULS flex√£o, flexo-comp N+M, cisalhamento Modelo I, verifica√ß√£o de tor√ß√£o por tens√µes de cisalhamento e intera√ß√£o V‚ÄìT,
          mais ELS b√°sico (fissura√ß√£o/flecha).  
          Se voc√™ quiser, no pr√≥ximo passo a gente bate caso real (dados de obra ou AltoQi/TQS) pra ir calibrando coeficiente por coeficiente.
        </p>
      `;
    }
  </script>
</body>
</html>
