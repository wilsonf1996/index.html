<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Pilar CA â€“ Nâ€“M (ELU/ELS) â€“ Wilson Fernandes Junior</title>
<style>
  * { box-sizing: border-box; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
  body {
    margin: 0;
    padding: 0;
    background: #020617;
    color: #e5e7eb;
    font-size: 13px;
  }
  .app {
    max-width: 1200px;
    margin: 16px auto;
    padding: 16px;
  }
  h1 { margin: 0 0 4px 0; font-size: 22px; text-align: center; }
  .subtitle {
    text-align: center;
    font-size: 12px;
    color: #9ca3af;
    margin-bottom: 12px;
  }
  .credit {
    text-align: center;
    font-size: 11px;
    color: #6b7280;
    margin-bottom: 16px;
  }
  .grid {
    display: grid;
    grid-template-columns: minmax(0, 0.9fr) minmax(0, 1.1fr);
    gap: 12px;
  }
  .card {
    background: #020617;
    border-radius: 16px;
    padding: 12px;
    border: 1px solid #111827;
    box-shadow: 0 18px 45px rgba(0,0,0,0.75);
  }
  h2 { margin: 0 0 8px 0; font-size: 15px; }
  label {
    display: block;
    font-size: 11px;
    margin-bottom: 2px;
  }
  input[type="number"], input[type="text"], select {
    width: 100%;
    padding: 5px 8px;
    border-radius: 8px;
    border: 1px solid #1f2937;
    background: #020617;
    color: #e5e7eb;
    font-size: 12px;
  }
  input:focus, select:focus {
    outline: none;
    border-color: #22c55e;
    box-shadow: 0 0 0 1px #22c55e66;
  }
  .row {
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 6px;
  }
  .field { margin-bottom: 7px; }
  .small { font-size: 11px; color:#9ca3af; }
  .btn-row {
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin-top:10px;
    justify-content:center;
  }
  button {
    border-radius:999px;
    padding:7px 16px;
    border:none;
    font-size:13px;
    font-weight:600;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    transition:transform .08s ease, box-shadow .08s ease, background .12s ease;
  }
  button.primary {
    background:linear-gradient(135deg,#22c55e,#16a34a);
    color:#022c22;
    box-shadow:0 12px 35px rgba(34,197,94,0.55);
  }
  button.secondary {
    background:#020617;
    color:#e5e7eb;
    border:1px solid #374151;
  }
  button:hover { transform:translateY(-1px); box-shadow:0 16px 40px rgba(0,0,0,0.7);}
  button:active { transform:translateY(0); box-shadow:none;}
  #saida {
    font-size: 12px;
    line-height: 1.45;
    max-height: 650px;
    overflow-y: auto;
  }
  hr {
    border:none;
    border-top:1px solid #111827;
    margin:8px 0;
  }
  .section-title {
    font-weight:600;
    margin-top:8px;
  }
  ul { margin:4px 0 4px 15px; padding:0; }
  .tag {
    display:inline-block;
    padding:1px 7px;
    border-radius:999px;
    font-size:10px;
    border:1px solid transparent;
    margin-right:4px;
  }
  .tag-ok { background:#022c22; border-color:#16a34a; color:#4ade80; }
  .tag-warn { background:#451a03; border-color:#facc15; color:#facc15; }
  .tag-err { background:#450a0a; border-color:#f97373; color:#fca5a5; }
  @media (max-width: 980px){
    .grid { grid-template-columns:1fr; }
  }
</style>
</head>
<body>
<div class="app">
  <h1>Pilar CA â€“ Nâ€“M (ELU + ELS)</h1>
  <div class="subtitle">
    SeÃ§Ã£o retangular, flexo-compressÃ£o / flexo-traÃ§Ã£o uniaxial.<br>
    ELU com bloco retangular completo (Nâ€“M iterando em x e As). ELS com Ïƒ<sub>s,ser</sub> e flecha aproximada.
  </div>
  <div class="credit">
    NÃºcleo de cÃ¡lculo especificado por <b>Wilson Fernandes Junior</b>.
  </div>

  <div class="grid">
    <!-- ENTRADAS -->
    <div class="card">
      <h2>1. Dados bÃ¡sicos</h2>
      <div class="field">
        <label>Obra / Projeto (opcional)</label>
        <input type="text" id="obra" placeholder="Ex.: GalpÃ£o â€“ Pilar P1">
      </div>
      <div class="row">
        <div class="field">
          <label>ID do pilar</label>
          <input type="text" id="idPilar" value="P1">
        </div>
        <div class="field">
          <label>Eng. responsÃ¡vel</label>
          <input type="text" id="engenheiro" value="Eng. ...">
        </div>
      </div>

      <hr>
      <h2>2. Materiais</h2>
      <div class="row">
        <div class="field">
          <label>fck (MPa)</label>
          <input type="number" id="fck" value="30" step="1">
        </div>
        <div class="field">
          <label>fyk (MPa) â€“ CA-50 â‰ˆ 500</label>
          <input type="number" id="fyk" value="500" step="10">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Î³c</label>
          <input type="number" id="gamma_c" value="1.4" step="0.05">
        </div>
        <div class="field">
          <label>Î³s</label>
          <input type="number" id="gamma_s" value="1.15" step="0.05">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Es (MPa)</label>
          <input type="number" id="Es" value="210000" step="1000">
        </div>
        <div class="field">
          <label>Ï† â€“ fluÃªncia (para ELS / 2Âª ordem local)</label>
          <input type="number" id="phi_creep" value="2.0" step="0.1">
        </div>
      </div>
      <div class="small">
        Eci â‰ˆ 5600Â·âˆšfck. Ec â‰ˆ 0,85Â·Eci. Para longo prazo, Ec,eff â‰ˆ Ec/(1+Ï†).
      </div>

      <hr>
      <h2>3. SeÃ§Ã£o retangular</h2>
      <div class="row">
        <div class="field">
          <label>b (cm) â€“ largura</label>
          <input type="number" id="b" value="25" step="0.5">
        </div>
        <div class="field">
          <label>h (cm) â€“ altura (direÃ§Ã£o do momento)</label>
          <input type="number" id="h" value="40" step="0.5">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Cobrimento (cm)</label>
          <input type="number" id="cob" value="3" step="0.5">
        </div>
        <div class="field">
          <label>Ï• barras long. (mm)</label>
          <input type="number" id="phi_long" value="16" step="2">
        </div>
      </div>
      <div class="field">
        <label>â„“<sub>0</sub> (m) â€“ comprimento equivalente do pilar</label>
        <input type="number" id="l0" value="3.0" step="0.1">
      </div>

      <hr>
      <h2>4. EsforÃ§os â€“ ELU (Nsd, Msd)</h2>
      <div class="small">
        Sinal de Nsd: compressÃ£o positiva, traÃ§Ã£o negativa. Momento em kNÂ·m, flexÃ£o uniaxial.
      </div>
      <div class="row">
        <div class="field">
          <label>Nsd (kN)</label>
          <input type="number" id="Nsd" value="1000" step="10">
        </div>
        <div class="field">
          <label>Msd (kNÂ·m)</label>
          <input type="number" id="Msd" value="60" step="1">
        </div>
      </div>

      <hr>
      <h2>5. EsforÃ§os â€“ ELS (Nser, Mser)</h2>
      <div class="small">
        AproximaÃ§Ã£o: use combinaÃ§Ãµes quase permanentes / frequentes. Usado para Ïƒ<sub>s,ser</sub> e flecha.
      </div>
      <div class="row">
        <div class="field">
          <label>Nser (kN)</label>
          <input type="number" id="Nser" value="700" step="10">
        </div>
        <div class="field">
          <label>Mser (kNÂ·m)</label>
          <input type="number" id="Mser" value="40" step="1">
        </div>
      </div>

      <hr>
      <h2>6. Modo de uso</h2>
      <div class="row">
        <div class="field">
          <label>Modo de cÃ¡lculo</label>
          <select id="modo">
            <option value="dimensionar">Dimensionar As (Nâ€“M)</option>
            <option value="verificar">Somente verificar (As dado)</option>
          </select>
        </div>
        <div class="field">
          <label>As,total informado (mmÂ²) â€“ sÃ³ no modo verificaÃ§Ã£o</label>
          <input type="number" id="As_inf" value="1600" step="10">
        </div>
      </div>
      <div class="small">
        No modo <b>dimensionar</b>, o app busca As<sub>t</sub> e As'<sub>c</sub> que satisfaÃ§am Nâ€“M com bloco 0,68Â·fcdÂ·bÂ·x,
        iterando x de 0,05Â·d atÃ© 0,45Â·d (domÃ­nio 3). No modo <b>verificar</b>, ele calcula Nrd, Mrd e FS.
      </div>

      <div class="btn-row">
        <button class="primary" onclick="calcular()">âš™ï¸ Calcular pilar</button>
        <button class="secondary" onclick="limpar()">ğŸ§¹ Limpar saÃ­da</button>
      </div>
    </div>

    <!-- RESULTADOS -->
    <div class="card">
      <h2>Resultados</h2>
      <div id="saida">
        <p>Preencha os dados e clique em <b>Calcular pilar</b>.</p>
      </div>
    </div>
  </div>
</div>

<script>
function fmt(x, d=2) {
  if (!isFinite(x)) return "-";
  return x.toLocaleString("pt-BR", {minimumFractionDigits:d, maximumFractionDigits:d});
}
function limpar(){
  document.getElementById("saida").innerHTML =
    "<p>Preencha os dados e clique em <b>Calcular pilar</b>.</p>";
}

// ÏmÃ­n de flexÃ£o (vigas/pilares, CA-50) ~ tabela Bastos, usado como referÃªncia
function rhoMinFlexao(fck){
  const fcks = [20,25,30,35,40,45,50,55,60,65,70,75,80,85,90];
  const rhosPct = [0.150,0.150,0.150,0.164,0.179,0.194,0.208,0.211,0.219,0.226,0.233,0.239,0.245,0.251,0.256];
  if (fck <= fcks[0]) return rhosPct[0]/100;
  if (fck >= fcks[fcks.length-1]) return rhosPct[rhosPct.length-1]/100;
  for (let i=0;i<fcks.length-1;i++){
    if (fck>=fcks[i] && fck<=fcks[i+1]){
      const t = (fck - fcks[i])/(fcks[i+1]-fcks[i]);
      const rhoPct = rhosPct[i] + t*(rhosPct[i+1]-rhosPct[i]);
      return rhoPct/100;
    }
  }
  return 0.0015;
}

// Solver de dimensionamento Nâ€“M (compressÃ£o) com bloco retangular 0,68 fcd b x.
// Assume aÃ§o em traÃ§Ã£o e compressÃ£o a fyd (domÃ­nio ~3). Busca x em [0,05d, 0,45d] e
// escolhe soluÃ§Ã£o com menor As_total dentro de [As_min, As_max].
function dimensionarNM_compressao(Nsd_kN, Msd_kNm, b_mm, d_mm, dLinha_mm, fcd, fyd, As_min_mm2, As_max_mm2){
  const Nsd_N = Nsd_kN*1000;
  const Msd_Nmm = Msd_kNm*1e6;
  const x_lim = 0.45*d_mm;
  const x_min = 0.05*d_mm;
  let melhor = null;

  for (let i=0;i<=100;i++){
    const x = x_min + (x_lim-x_min)*i/100;
    const Cc = 0.68 * fcd * b_mm * x;      // N
    const yc = 0.4 * x;                    // mm
    const ys = dLinha_mm;                  // aÃ§o comprimido
    const yt = d_mm;                       // aÃ§o tracionado

    const A = Nsd_N - Cc;
    const B = Msd_Nmm - Cc*yc;
    const den = (ys - yt);
    if (Math.abs(den) < 1e-6) continue;

    const T = (B - A*ys)/den;   // traÃ§Ã£o (N)
    const Cs = T + A;           // compressÃ£o (N)

    if (T <= 0) continue;       // sem traÃ§Ã£o â†’ nÃ£o faz sentido
    if (Cs < 0) continue;       // aÃ§o comprimido negativo

    const As_t = T / fyd;       // mmÂ²
    const As_c = Cs / fyd;      // mmÂ²
    const As_tot = As_t + As_c;
    if (As_tot < As_min_mm2 || As_tot > As_max_mm2) continue;

    if (!melhor || As_tot < melhor.As_tot){
      melhor = {x, As_t, As_c, As_tot, Cc, T, Cs};
    }
  }
  return melhor;
}

// VerificaÃ§Ã£o de Nâ€“M com As_total dado (bem aproximado)
// Considera As simÃ©trica (As/2 traÃ§Ã£o, As/2 compressÃ£o) no braÃ§o d e d'.
function verificarNM(Nsd_kN, Msd_kNm, b_mm, d_mm, dLinha_mm, fcd, fyd, As_tot_mm2){
  const Nsd_N = Nsd_kN*1000;
  const Msd_Nmm = Msd_kNm*1e6;

  // Vamos localizar x por tentativa, usando mesmo esquema, mas com As fixo.
  // SupÃµe As_t = As_c = As_tot/2.
  const As_t = As_tot_mm2/2;
  const As_c = As_tot_mm2/2;
  const x_lim = 0.45*d_mm;
  const x_min = 0.05*d_mm;
  let melhor = null;

  for (let i=0;i<=100;i++){
    const x = x_min + (x_lim-x_min)*i/100;
    const Cc = 0.68*fcd*b_mm*x;
    const yc = 0.4*x;
    const ys = dLinha_mm;
    const yt = d_mm;

    const T = As_t * fyd;
    const Cs = As_c * fyd;

    const Nint = Cc + Cs - T;
    const Mint = Cc*yc + Cs*ys - T*yt;

    const errN = Nint - Nsd_N;
    const errM = Mint - Msd_Nmm;
    const erro = Math.sqrt(errN*errN + errM*errM);

    if (!melhor || erro < melhor.erro){
      melhor = {x, Cc, Cs, T, Nint, Mint, erro};
    }
  }

  if (!melhor) return null;

  const Mrd_kNm = melhor.Mint/1e6;
  const Nrd_kN = melhor.Nint/1000.0;

  const FS_N = (Nsd_kN !== 0) ? (Nrd_kN/Nsd_kN) : Infinity;
  const FS_M = (Msd_kNm !== 0) ? (Mrd_kNm/Msd_kNm) : Infinity;

  return {
    x: melhor.x,
    Cc: melhor.Cc,
    Cs: melhor.Cs,
    T: melhor.T,
    Nrd_kN,
    Mrd_kNm,
    FS_N,
    FS_M
  };
}

function calcular(){
  const out = document.getElementById("saida");
  try{
    const obra = (document.getElementById("obra").value || "").trim();
    const idPilar = (document.getElementById("idPilar").value || "").trim();
    const engenheiro = (document.getElementById("engenheiro").value || "").trim();

    const fck = parseFloat(document.getElementById("fck").value);
    const fyk = parseFloat(document.getElementById("fyk").value);
    const gamma_c = parseFloat(document.getElementById("gamma_c").value);
    const gamma_s = parseFloat(document.getElementById("gamma_s").value);
    const Es = parseFloat(document.getElementById("Es").value);
    const phi_creep = parseFloat(document.getElementById("phi_creep").value);

    const b_cm = parseFloat(document.getElementById("b").value);
    const h_cm = parseFloat(document.getElementById("h").value);
    const cob_cm = parseFloat(document.getElementById("cob").value);
    const phi_long = parseFloat(document.getElementById("phi_long").value);
    const l0_m = parseFloat(document.getElementById("l0").value);

    const Nsd_kN = parseFloat(document.getElementById("Nsd").value);
    const Msd_kNm = parseFloat(document.getElementById("Msd").value);
    const Nser_kN = parseFloat(document.getElementById("Nser").value || "0");
    const Mser_kNm = parseFloat(document.getElementById("Mser").value || "0");

    const modo = document.getElementById("modo").value;
    const As_inf_mm2 = parseFloat(document.getElementById("As_inf").value || "0");

    if (!isFinite(fck) || fck<=0 || !isFinite(fyk) || !isFinite(b_cm) || !isFinite(h_cm) || !isFinite(Nsd_kN) || !isFinite(Msd_kNm)){
      out.innerHTML = "<p><span class='tag tag-err'>Erro</span> Verifique fck, fyk, b, h, Nsd, Msd.</p>";
      return;
    }

    const fcd = 0.85 * fck / gamma_c;
    const fyd = fyk / gamma_s;
    const Eci = 5600*Math.sqrt(fck);
    const Ec = 0.85*Eci;
    const Ec_eff = Ec / (1 + phi_creep);

    const b_mm = b_cm*10;
    const h_mm = h_cm*10;
    const cob_mm = cob_cm*10;
    const d_mm = h_mm - cob_mm - phi_long/2;
    const dLinha_mm = cob_mm + phi_long/2;
    if (d_mm <= 0){
      out.innerHTML = "<p><span class='tag tag-err'>Geometria invÃ¡lida</span> d ficou â‰¤ 0. Verifique h, cobrimento e Ï•.</p>";
      return;
    }

    const Ac_mm2 = b_mm*h_mm;
    const Ix_mm4 = b_mm*Math.pow(h_mm,3)/12;
    const i_mm = Math.sqrt(Ix_mm4/Ac_mm2);
    const l0_mm = l0_m*1000;
    const lambda = l0_mm / i_mm;

    // limites As
    const rho_min = rhoMinFlexao(fck);
    const As_min_mm2 = rho_min * Ac_mm2;
    const As_max_mm2 = 0.04 * Ac_mm2; // 4%Â·Ac

    const Nsd_N = Nsd_kN*1000;
    const Msd_Nmm = Msd_kNm*1e6;

    let html = "";
    html += `<p><b>Pilar ${idPilar || "-"}</b> â€“ SeÃ§Ã£o retangular b=${fmt(b_cm,1)} cm, h=${fmt(h_cm,1)} cm.<br>`;
    if (obra) html += `Obra: <b>${obra}</b><br>`;
    html += `Eng.: <b>${engenheiro || "-"}</b></p>`;

    let tagN = "";
    if (Nsd_kN > 0) tagN = "<span class='tag tag-ok'>CompressÃ£o (Nsd &gt; 0)</span>";
    else if (Nsd_kN < 0) tagN = "<span class='tag tag-warn'>TraÃ§Ã£o (Nsd &lt; 0)</span>";
    else tagN = "<span class='tag tag-warn'>Nsd = 0 (flexÃ£o pura)</span>";

    html += `<p><b>Materiais / ResistÃªncias:</b><br>
      fck = ${fmt(fck,0)} MPa â‡’ fcd â‰ˆ ${fmt(fcd,2)} MPa<br>
      fyk = ${fmt(fyk,0)} MPa â‡’ fyd â‰ˆ ${fmt(fyd,2)} MPa<br>
      Eci â‰ˆ ${fmt(Eci,0)} MPa; Ec â‰ˆ ${fmt(Ec,0)} MPa; Ec,eff â‰ˆ ${fmt(Ec_eff,0)} MPa (Ï†=${fmt(phi_creep,2)})</p>`;

    html += `<p><b>Geometria:</b><br>
      Ac â‰ˆ ${fmt(Ac_mm2/100,2)} cmÂ²;<br>
      Ix â‰ˆ ${fmt(Ix_mm4/1e4,2)} cmâ´; i â‰ˆ ${fmt(i_mm/10,2)} cm<br>
      d â‰ˆ ${fmt(d_mm/10,2)} cm; d' â‰ˆ ${fmt(dLinha_mm/10,2)} cm<br>
      â„“â‚€ = ${fmt(l0_m,2)} m â‡’ Î» â‰ˆ ${fmt(lambda,1)}</p>`;

    html += `<p><b>EsforÃ§os:</b> ${tagN}<br>
      ELU: Nsd = ${fmt(Nsd_kN,1)} kN; Msd = ${fmt(Msd_kNm,1)} kNÂ·m<br>
      ELS: Nser = ${fmt(Nser_kN,1)} kN; Mser = ${fmt(Mser_kNm,1)} kNÂ·m</p>`;

    html += `<p><b>Taxas As (limites normativos de referÃªncia):</b><br>
      ÏmÃ­n â‰ˆ ${fmt(rho_min*100,3)} % â‡’ As,min â‰ˆ ${fmt(As_min_mm2,1)} mmÂ²<br>
      ÏmÃ¡x = 4% â‡’ As,max â‰ˆ ${fmt(As_max_mm2,1)} mmÂ²</p>`;

    if (modo === "dimensionar"){
      // dimensionamento
      if (Nsd_kN > 0){
        // Flexo-compressÃ£o: usar solver Nâ€“M
        const sol = dimensionarNM_compressao(Nsd_kN, Msd_kNm, b_mm, d_mm, dLinha_mm, fcd, fyd, As_min_mm2, As_max_mm2);
        if (!sol){
          html += `<p class="section-title">Dimensionamento Nâ€“M (compressÃ£o)</p>
                   <p><span class='tag tag-err'>NÃ£o convergiu</span> NÃ£o foi encontrada soluÃ§Ã£o razoÃ¡vel para Nâ€“M com x/d â‰¤ 0,45 e As entre [Asmin, Asmax].</p>`;
        } else {
          const x = sol.x;
          const x_d = x/d_mm;
          const eps_cu = 0.0035;
          const eps_y = fyd/Es;
          const eps_s_t = eps_cu*(d_mm - x)/x;
          const eps_s_c = eps_cu*(x - dLinha_mm)/x;

          html += `<p class="section-title">Dimensionamento Nâ€“M (flexo-compressÃ£o)</p>`;
          html += `<p>Solucionado com iteraÃ§Ã£o em x.<br>
            x â‰ˆ ${fmt(x,2)} mm â‡’ x/d â‰ˆ ${fmt(x_d,3)} (limite â‰ˆ 0,45)<br>
            Cc â‰ˆ ${fmt(sol.Cc/1000,1)} kN; T (aÃ§o traÃ§Ã£o) â‰ˆ ${fmt(sol.T/1000,1)} kN; Cs (aÃ§o compressÃ£o) â‰ˆ ${fmt(sol.Cs/1000,1)} kN</p>`;

          html += `<p><b>Armaduras obtidas:</b><br>
            As<sub>t</sub> (traÃ§Ã£o) â‰ˆ <b>${fmt(sol.As_t,1)} mmÂ²</b> â‰ˆ ${fmt(sol.As_t/100,2)} cmÂ²<br>
            As'<sub>c</sub> (compressÃ£o) â‰ˆ <b>${fmt(sol.As_c,1)} mmÂ²</b> â‰ˆ ${fmt(sol.As_c/100,2)} cmÂ²<br>
            As,total â‰ˆ <b>${fmt(sol.As_tot,1)} mmÂ²</b> (entre As,min e As,max)</p>`;

          html += `<p><b>DeformaÃ§Ãµes de cÃ¡lculo (referÃªncia):</b><br>
            Îµc,u â‰ˆ 3,50 â€°<br>
            Îµs,t â‰ˆ ${fmt(eps_s_t*1000,3)} â€° (Îµy â‰ˆ ${fmt(eps_y*1000,3)} â€°) â‡’ aÃ§o tracionado ${eps_s_t>=eps_y ? "no escoamento" : "antes do escoamento"}<br>
            Îµs,c â‰ˆ ${fmt(eps_s_c*1000,3)} â€° â‡’ aÃ§o comprimido ${eps_s_c>=eps_y ? "no escoamento" : "antes do escoamento"}</p>`;

          html += `<p class="small">
            ObservaÃ§Ã£o: o algoritmo resolveu Nâ€“M usando bloco retangular 0,68Â·fcdÂ·bÂ·x e aÃ§o tracionado/comprimido com tensÃ£o â‰ˆ fyd.
            Em regiÃµes onde Îµs &lt; Îµy, o diagrama real Ã© um pouco mais â€œmoleâ€, mas isso costuma ser conservador para dimensionamento.
          </p>`;
        }
      } else {
        // Nsd <= 0 â†’ flexo-traÃ§Ã£o: concreto quase todo tracionado, aÃ§o leva N+M
        const Nten_kN = Math.abs(Nsd_kN);
        const Nten_N = Nten_kN*1000;
        const As_N = Nten_N/fyd;
        const z_mm = 0.9*d_mm;
        const As_M = (Msd_kNm>0) ? (Msd_Nmm/(fyd*z_mm)) : 0;
        let As_tot = As_N + As_M;
        As_tot = Math.max(As_tot, As_min_mm2);
        As_tot = Math.min(As_tot, As_max_mm2*0.9);

        html += `<p class="section-title">Dimensionamento Nâ€“M (flexo-traÃ§Ã£o â€“ Nsd â‰¤ 0)</p>`;
        html += `<p>Concreto praticamente nÃ£o contribui na zona tracionada. Toda traÃ§Ã£o Ã© levada pelo aÃ§o.</p>`;
        html += `<p><b>Armaduras estimadas:</b><br>
          As para N (traÃ§Ã£o) â‰ˆ ${fmt(As_N,1)} mmÂ²<br>
          As para M (flexÃ£o) â‰ˆ ${fmt(As_M,1)} mmÂ² (zâ‰ˆ0,9Â·d)<br>
          As,total sugerida â‰ˆ <b>${fmt(As_tot,1)} mmÂ²</b> (entre As,min e As,max)</p>`;
      }
    } else {
      // modo verificaÃ§Ã£o â€“ As,total informado
      const As_tot = As_inf_mm2;
      if (!isFinite(As_tot) || As_tot <= 0){
        out.innerHTML = "<p><span class='tag tag-err'>Erro</span> As,total informado invÃ¡lido para verificaÃ§Ã£o.</p>";
        return;
      }
      html += `<p class="section-title">VerificaÃ§Ã£o Nâ€“M com As,total = ${fmt(As_tot,1)} mmÂ²</p>`;

      const As_text = (As_tot < As_min_mm2)
        ? "<span class='tag tag-err'>As &lt; As,min</span>"
        : (As_tot > As_max_mm2)
          ? "<span class='tag tag-err'>As &gt; As,max (4%Â·Ac)</span>"
          : "<span class='tag tag-ok'>As entre As,min e As,max</span>";

      html += `<p>${As_text}</p>`;

      const ver = verificarNM(Nsd_kN, Msd_kNm, b_mm, d_mm, dLinha_mm, fcd, fyd, As_tot);
      if (!ver){
        html += `<p><span class='tag tag-err'>Falha</span> NÃ£o foi possÃ­vel ajustar Nâ€“M com As,total informado.</p>`;
      } else {
        const x = ver.x;
        const x_d = x/d_mm;
        const eps_cu = 0.0035;
        const eps_y = fyd/Es;
        const eps_s_t = eps_cu*(d_mm - x)/x;
        const eps_s_c = eps_cu*(x - dLinha_mm)/x;

        html += `<p><b>EquilÃ­brio aproximado:</b><br>
          x â‰ˆ ${fmt(x,2)} mm â‡’ x/d â‰ˆ ${fmt(x_d,3)}<br>
          Nrd â‰ˆ ${fmt(ver.Nrd_kN,1)} kN â‡’ FS<sub>N</sub> â‰ˆ ${fmt(ver.FS_N,2)}<br>
          Mrd â‰ˆ ${fmt(ver.Mrd_kNm,1)} kNÂ·m â‡’ FS<sub>M</sub> â‰ˆ ${fmt(ver.FS_M,2)}</p>`;

        html += `<p><b>DeformaÃ§Ãµes de cÃ¡lculo (referÃªncia):</b><br>
          Îµc,u â‰ˆ 3,50 â€°<br>
          Îµs,t â‰ˆ ${fmt(eps_s_t*1000,3)} â€° (Îµy â‰ˆ ${fmt(eps_y*1000,3)} â€°)<br>
          Îµs,c â‰ˆ ${fmt(eps_s_c*1000,3)} â€°</p>`;
      }
    }

    // ELS rÃ¡pido â€“ fissuraÃ§Ã£o e flecha aproximada
    // Ïƒs,ser â‰ˆ Mser / (As_t * z_ser) (se dimensionado) ou Mser / (As_inf * z) (se verificaÃ§Ã£o)
    const z_ser_mm = 0.9*d_mm;
    const Mser_Nmm = Mser_kNm*1e6;
    let As_uso_MM2 = As_inf_mm2;
    if (modo === "dimensionar"){
      // se dimensionamos, tentar usar As obtido (melhor aproximaÃ§Ã£o)
      // como nÃ£o guardamos global, deixamos um comentÃ¡rio genÃ©rico:
      // poderia refinar salvando As do dimensionamento.
    }

    let sigma_s_ser = NaN;
    if (Mser_kNm !== 0 && As_inf_mm2>0){
      sigma_s_ser = Mser_Nmm / (As_inf_mm2 * z_ser_mm); // MPa
    }

    // flecha aproximada (simplesmente apoiado): Î´ â‰ˆ MserÂ·l0Â²/(8Â·Ec,effÂ·I)
    const delta_mm = (Mser_kNm !== 0)
      ? (Mser_Nmm * Math.pow(l0_mm,2) / (8*Ec_eff*Ix_mm4))
      : 0;
    const lim_def_mm = l0_mm/250;

    html += `<hr><p class="section-title">ELS â€“ verificaÃ§Ã£o qualitativa</p>`;
    html += `<p><b>Flecha lateral (estimativa simples):</b><br>
      Î´<sub>ser</sub> â‰ˆ ${fmt(delta_mm,1)} mm; limite tÃ­pico L/250 â‰ˆ ${fmt(lim_def_mm,1)} mm<br>`;
    if (delta_mm <= lim_def_mm){
      html += `<span class='tag tag-ok'>Flecha estimada dentro de L/250</span>`;
    } else {
      html += `<span class='tag tag-warn'>Flecha estimada acima de L/250 (verificar modelo mais refinado)</span>`;
    }
    html += `</p>`;

    if (isFinite(sigma_s_ser)){
      html += `<p><b>TensÃ£o de serviÃ§o no aÃ§o (estimativa):</b><br>
        Ïƒ<sub>s,ser</sub> â‰ˆ ${fmt(sigma_s_ser,1)} MPa<br>`;
      if (sigma_s_ser <= 160){
        html += `<span class='tag tag-ok'>TensÃ£o baixa â†’ fissuraÃ§Ã£o pequena</span>`;
      } else if (sigma_s_ser <= 240){
        html += `<span class='tag tag-warn'>TensÃ£o moderada â†’ fissuras em nÃ­vel usual de pilares</span>`;
      } else {
        html += `<span class='tag tag-err'>TensÃ£o elevada â†’ risco de fissuras mais abertas</span>`;
      }
    } else {
      html += `<p><b>TensÃ£o de serviÃ§o no aÃ§o:</b> informe Mser e As,total para estimar Ïƒ<sub>s,ser</sub>.</p>`;
    }

    html += `<p class="small">
      ObservaÃ§Ã£o: o ELS aqui Ã© <b>aproximado</b> (curvatura simplificada, flecha tipo viga biapoiada).
      Para verificaÃ§Ã£o normativa fina de fissuraÃ§Ã£o e flecha de pilares, ainda Ã© recomendÃ¡vel usar
      um software dedicado ou aplicar diretamente as expressÃµes completas da NBR 6118.
    </p>`;

    out.innerHTML = html;

  } catch(e){
    console.error(e);
    out.innerHTML = "<p><span class='tag tag-err'>Erro inesperado</span> â€“ revise os dados de entrada.</p>";
  }
}
</script>
</body>
</html>
