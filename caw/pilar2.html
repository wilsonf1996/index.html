<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Pilar de Concreto Armado ‚Äì NBR 6118 (ELU/ELS) ‚Äì Wilson Fernandes Junior</title>
<style>
  * { box-sizing: border-box; font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
  body {
    margin: 0;
    padding: 0;
    background: #020617;
    color: #e5e7eb;
  }
  .app {
    max-width: 1400px;
    margin: 16px auto;
    padding: 16px;
  }
  h1 {
    margin: 0 0 4px 0;
    font-size: 22px;
    text-align: center;
  }
  .subtitle {
    text-align: center;
    font-size: 12px;
    color: #9ca3af;
    margin-bottom: 16px;
  }
  .grid {
    display: grid;
    grid-template-columns: minmax(0, 0.95fr) minmax(0, 1.05fr);
    gap: 12px;
  }
  .card {
    background: #020617;
    border-radius: 16px;
    padding: 12px;
    border: 1px solid #111827;
    box-shadow: 0 18px 45px rgba(0,0,0,0.75);
  }
  .card h2 {
    margin: 0 0 8px 0;
    font-size: 15px;
  }
  label {
    display: block;
    font-size: 11px;
    margin-bottom: 2px;
  }
  input[type="number"], input[type="text"], select {
    width: 100%;
    padding: 5px 8px;
    border-radius: 8px;
    border: 1px solid #1f2937;
    background: #020617;
    color: #e5e7eb;
    font-size: 12px;
  }
  input:focus, select:focus {
    outline: none;
    border-color: #22c55e;
    box-shadow: 0 0 0 1px #22c55e66;
  }
  .row {
    display: grid;
    grid-template-columns: repeat(2, minmax(0,1fr));
    gap: 6px;
  }
  .field { margin-bottom: 7px; }
  .small { font-size: 11px; color:#9ca3af; }
  .tag {
    display: inline-block;
    font-size: 10px;
    padding: 2px 7px;
    border-radius: 999px;
    border: 1px solid transparent;
    margin-right: 4px;
  }
  .tag-ok { background:#022c22; border-color:#16a34a; color:#4ade80; }
  .tag-warn { background:#451a03; border-color:#facc15; color:#facc15; }
  .tag-err { background:#450a0a; border-color:#f97373; color:#fca5a5; }
  .btn-row {
    display:flex;
    flex-wrap:wrap;
    gap:10px;
    margin-top:10px;
    justify-content:center;
  }
  button {
    border-radius:999px;
    padding:7px 16px;
    border:none;
    font-size:13px;
    font-weight:600;
    cursor:pointer;
    display:inline-flex;
    align-items:center;
    gap:6px;
    transition:transform .08s ease, box-shadow .08s ease, background .12s ease;
  }
  button.primary {
    background:linear-gradient(135deg,#22c55e,#16a34a);
    color:#022c22;
    box-shadow:0 12px 35px rgba(34,197,94,0.55);
  }
  button.secondary {
    background:#020617;
    color:#e5e7eb;
    border:1px solid #374151;
  }
  button:hover { transform:translateY(-1px); box-shadow:0 16px 40px rgba(0,0,0,0.7);}
  button:active { transform:translateY(0); box-shadow:none;}
  #saida {
    font-size: 12px;
    line-height: 1.45;
    max-height: 650px;
    overflow-y: auto;
  }
  hr {
    border:none;
    border-top:1px solid #111827;
    margin:8px 0;
  }
  .section-title {
    font-weight:600;
    margin-top:6px;
  }
  ul { margin:4px 0 4px 15px; padding:0; }
  @media (max-width: 980px){
    .grid { grid-template-columns:1fr; }
  }
</style>
</head>
<body>
<div class="app">
  <h1>Pilar de Concreto Armado ‚Äì NBR 6118 (ELU / ELS)</h1>
  <div class="subtitle">
    C√°lculo aproximado de um pilar isolado (retangular ou circular).<br>
    Verifica√ß√£o de esbeltez (Œª, Œª‚ÇÅ), Œ≥<sub>z</sub>, 2¬™ ordem local, compress√£o/tra√ß√£o, estimativa de As.
    <br><b>Autor do app: Wilson Fernandes Junior (conceito / ideia)</b>
  </div>

  <div class="grid">
    <!-- ENTRADAS -->
    <div class="card">
      <h2>1. Dados gerais</h2>
      <div class="field">
        <label>Nome da obra / projeto (opcional)</label>
        <input type="text" id="obra" placeholder="Ex.: Edif√≠cio XPTO ‚Äì Torre A">
      </div>
      <div class="row">
        <div class="field">
          <label>Identifica√ß√£o do pilar</label>
          <input type="text" id="idPilar" value="P1">
        </div>
        <div class="field">
          <label>Engenheiro respons√°vel (nome)</label>
          <input type="text" id="engenheiro" value="Eng. ....">
        </div>
      </div>
      <hr>

      <h2>2. Materiais</h2>
      <div class="row">
        <div class="field">
          <label>fck (MPa)</label>
          <input type="number" id="fck" value="30" step="1">
        </div>
        <div class="field">
          <label>fyk longitudinal (MPa)</label>
          <input type="number" id="fyk_long" value="500" step="10">
        </div>
        <div class="field">
          <label>fyk estribos (MPa)</label>
          <input type="number" id="fyk_trans" value="500" step="10">
        </div>
        <div class="field">
          <label>Œ≥c (seguran√ßa concreto)</label>
          <input type="number" id="gamma_c" value="1.4" step="0.05">
        </div>
        <div class="field">
          <label>Œ≥s (seguran√ßa a√ßo)</label>
          <input type="number" id="gamma_s" value="1.15" step="0.05">
        </div>
        <div class="field">
          <label>œÜ (flu√™ncia, se Œª &gt; 90) ‚Äì estimativa</label>
          <input type="number" id="phi_creep" value="2.0" step="0.1">
        </div>
      </div>
      <div class="small">
        Eci ‚âà 5600¬∑‚àöfck (MPa), conforme NBR / Bastos. Flu√™ncia entra na rigidez secante para 2¬™ ordem local. :contentReference[oaicite:6]{index=6}
      </div>

      <hr>
      <h2>3. Geometria da se√ß√£o</h2>
      <div class="field">
        <label>Tipo de se√ß√£o</label>
        <select id="tipoSecao">
          <option value="ret">Retangular</option>
          <option value="cir">Circular</option>
        </select>
      </div>
      <div id="geomRet">
        <div class="row">
          <div class="field">
            <label>b (cm) ‚Äì dimens√£o na dire√ß√£o x</label>
            <input type="number" id="b" value="25" step="0.5">
          </div>
          <div class="field">
            <label>h (cm) ‚Äì dimens√£o na dire√ß√£o y</label>
            <input type="number" id="h" value="40" step="0.5">
          </div>
        </div>
      </div>
      <div id="geomCir" style="display:none;">
        <div class="field">
          <label>Di√¢metro D (cm)</label>
          <input type="number" id="D" value="40" step="0.5">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Cobrimento c<sub>nom</sub> (cm)</label>
          <input type="number" id="cob" value="3.0" step="0.5">
        </div>
        <div class="field">
          <label>œï barras long. (mm)</label>
          <input type="number" id="phi_long" value="16" step="2">
        </div>
      </div>
      <hr>

      <h2>4. Comprimentos e sistema estrutural</h2>
      <div class="row">
        <div class="field">
          <label>‚Ñì<sub>0x</sub> (m) ‚Äì comprimento equivalente dire√ß√£o x</label>
          <input type="number" id="l0x" value="3.0" step="0.1">
        </div>
        <div class="field">
          <label>‚Ñì<sub>0y</sub> (m) ‚Äì comprimento equivalente dire√ß√£o y</label>
          <input type="number" id="l0y" value="3.0" step="0.1">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Tipo de pilar (para Œ±<sub>b</sub> ‚Äì Œª‚ÇÅ)</label>
          <select id="tipoAlphaB">
            <option value="biapoiado_sem_q">Biapoiado sem cargas transversais significativas</option>
            <option value="biapoiado_com_q">Biapoiado com cargas transversais significativas</option>
            <option value="balanco">Balan√ßo (engastado-livre)</option>
            <option value="outro">Outro / conservador (Œ±b = 1,0)</option>
          </select>
        </div>
        <div class="field">
          <label>Quadro global</label>
          <select id="quadro">
            <option value="fx">N√≥s fixos (Œ≥z ‚â§ 1,10)</option>
            <option value="mov">N√≥s m√≥veis (Œ≥z &gt; 1,10)</option>
          </select>
        </div>
      </div>
      <hr>

      <h2>5. Esfor√ßos solicitantes (ELU)</h2>
      <div class="row">
        <div class="field">
          <label>Nsd (kN) ‚Äì compress√£o (+), tra√ß√£o (‚àí)</label>
          <input type="number" id="Nsd" value="1000" step="10">
        </div>
        <div class="field">
          <label>Modo de c√°lculo</label>
          <select id="modoCalc">
            <option value="verificar">Somente verifica√ß√£o (As informada)</option>
            <option value="dimensionar">Dimensionar As (sugest√£o)</option>
          </select>
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Msd,x topo (kN¬∑m) ‚Äì flex√£o no plano xz (eixo y)</label>
          <input type="number" id="Msdx_top" value="50" step="1">
        </div>
        <div class="field">
          <label>Msd,x base (kN¬∑m)</label>
          <input type="number" id="Msdx_bot" value="60" step="1">
        </div>
      </div>
      <div class="row">
        <div class="field">
          <label>Msd,y topo (kN¬∑m) ‚Äì flex√£o no plano yz (eixo x)</label>
          <input type="number" id="Msdy_top" value="20" step="1">
        </div>
        <div class="field">
          <label>Msd,y base (kN¬∑m)</label>
          <input type="number" id="Msdy_bot" value="30" step="1">
        </div>
      </div>
      <div class="small">
        Para flex√£o obl√≠qua, o app trata cada dire√ß√£o (x,y) separadamente para Œª, Œª‚ÇÅ, M2d, e combina os
        resultados de forma aproximada (Mrd,x/Msd,x e Mrd,y/Msd,y).
      </div>

      <hr>
      <h2>6. Œ≥<sub>z</sub> global (NBR ‚Äì opcional)</h2>
      <div class="small">
        F√≥rmula da NBR (global do edif√≠cio): Œ≥<sub>z</sub> = 1 / (1 ‚àí ŒîM<sub>tot,d</sub> / M<sub>1,tot,d</sub>). :contentReference[oaicite:7]{index=7}  
        Se n√£o souber ŒîM/M1 de um p√≥rtico, deixe em branco que o app usa um Œ≥<sub>z</sub> ‚Äúinterno‚Äù
        aproximado com base em N<sub>cr</sub>.
      </div>
      <div class="row">
        <div class="field">
          <label>M<sub>1,tot,d</sub> (kN¬∑m) ‚Äì soma momentos 1¬™ ordem (edif√≠cio)</label>
          <input type="number" id="M1tot" step="1">
        </div>
        <div class="field">
          <label>ŒîM<sub>tot,d</sub> (kN¬∑m) ‚Äì soma P¬∑Œî (2¬™ ordem global)</label>
          <input type="number" id="DeltaMtot" step="1">
        </div>
      </div>

      <hr>
      <h2>7. Œ±<sub>c</sub> e Œ≤ (rigidez)</h2>
      <div class="row">
        <div class="field">
          <label>Œ≤ ‚Äì redu√ß√£o de in√©rcia (fissura√ß√£o, etc.)</label>
          <input type="number" id="betaI" value="0.7" step="0.05">
        </div>
        <div class="field">
          <label>Œ±<sub>c</sub> ‚Äì se vazio, calculado como Nsd/(Ac¬∑fcd)</label>
          <input type="number" id="alpha_c_manual" placeholder="deixe vazio p/ autom√°tico" step="0.05">
        </div>
      </div>

      <hr>
      <h2>8. Armadura longitudinal (somente verifica√ß√£o)</h2>
      <div class="small">Use apenas se modo = ‚Äúsomente verifica√ß√£o‚Äù. Em ‚Äúdimensionar‚Äù, o app ignora estes valores e
        prop√µe As sugerido.</div>
      <div id="armRet">
        <div class="row">
          <div class="field">
            <label>As face +y (mm¬≤)</label>
            <input type="number" id="As_y_pos" value="600" step="10">
          </div>
          <div class="field">
            <label>As face ‚àíy (mm¬≤)</label>
            <input type="number" id="As_y_neg" value="600" step="10">
          </div>
        </div>
        <div class="row">
          <div class="field">
            <label>As face +x (mm¬≤)</label>
            <input type="number" id="As_x_pos" value="400" step="10">
          </div>
          <div class="field">
            <label>As face ‚àíx (mm¬≤)</label>
            <input type="number" id="As_x_neg" value="400" step="10">
          </div>
        </div>
      </div>
      <div id="armCir" style="display:none;">
        <div class="row">
          <div class="field">
            <label>As,total (mm¬≤)</label>
            <input type="number" id="As_total_circ" value="1800" step="10">
          </div>
          <div class="field">
            <label>N¬∫ de barras (distribu√≠das no per√≠metro)</label>
            <input type="number" id="n_barras_circ" value="8" step="1">
          </div>
        </div>
      </div>

      <div class="btn-row">
        <button class="primary" onclick="calcular()">‚öôÔ∏è Calcular pilar</button>
        <button class="secondary" onclick="limpar()">üßπ Limpar sa√≠da</button>
      </div>
    </div>

    <!-- RESULTADOS -->
    <div class="card">
      <h2>Resultado resumido</h2>
      <div id="saida">
        <p>Preencha os dados do pilar e clique em <b>Calcular pilar</b>.</p>
      </div>
    </div>
  </div>
</div>

<script>
function fmt(x, d=2) {
  if (!isFinite(x)) return "-";
  return x.toLocaleString("pt-BR", {minimumFractionDigits:d, maximumFractionDigits:d});
}
function sgn(x){ return x>=0 ? 1 : -1; }

document.getElementById("tipoSecao").addEventListener("change", () => {
  const tipo = document.getElementById("tipoSecao").value;
  document.getElementById("geomRet").style.display = tipo === "ret" ? "block" : "none";
  document.getElementById("geomCir").style.display = tipo === "cir" ? "block" : "none";
  document.getElementById("armRet").style.display = tipo === "ret" ? "block" : "none";
  document.getElementById("armCir").style.display = tipo === "cir" ? "block" : "none";
});

function limpar(){
  document.getElementById("saida").innerHTML =
    "<p>Preencha os dados do pilar e clique em <b>Calcular pilar</b>.</p>";
}

// Esbeltez limite Œª1 (NBR 6118 / Bastos): Œª1 = (25 + 12,5¬∑e1/h)¬∑Œ±b, com 35 ‚â§ Œª1 ‚â§ 90
// Œ±b conforme tipo de diagrama de momentos e vincula√ß√£o. :contentReference[oaicite:8]{index=8}
function calcLambda1(e1_over_h, alphaB){
  const base = 25 + 12.5 * e1_over_h;
  const raw = base * alphaB;
  return Math.max(35, Math.min(raw, 90));
}

function calcular(){
  const saida = document.getElementById("saida");
  try{
    const obra = document.getElementById("obra").value.trim();
    const idPilar = document.getElementById("idPilar").value.trim();
    const engenheiro = document.getElementById("engenheiro").value.trim();

    const fck = parseFloat(document.getElementById("fck").value);
    const fyk_long = parseFloat(document.getElementById("fyk_long").value);
    const fyk_trans = parseFloat(document.getElementById("fyk_trans").value);
    const gamma_c = parseFloat(document.getElementById("gamma_c").value);
    const gamma_s = parseFloat(document.getElementById("gamma_s").value);
    const phi = parseFloat(document.getElementById("phi_creep").value);

    const tipoSecao = document.getElementById("tipoSecao").value;
    const cob_cm = parseFloat(document.getElementById("cob").value);
    const phi_long = parseFloat(document.getElementById("phi_long").value);

    const l0x_m = parseFloat(document.getElementById("l0x").value);
    const l0y_m = parseFloat(document.getElementById("l0y").value);
    const tipoAlphaB = document.getElementById("tipoAlphaB").value;
    const quadro = document.getElementById("quadro").value;

    const Nsd_kN = parseFloat(document.getElementById("Nsd").value);
    const Msdx_top = parseFloat(document.getElementById("Msdx_top").value);
    const Msdx_bot = parseFloat(document.getElementById("Msdx_bot").value);
    const Msdy_top = parseFloat(document.getElementById("Msdy_top").value);
    const Msdy_bot = parseFloat(document.getElementById("Msdy_bot").value);

    const modoCalc = document.getElementById("modoCalc").value;

    const M1tot_kNm = parseFloat(document.getElementById("M1tot").value || "NaN");
    const DeltaMtot_kNm = parseFloat(document.getElementById("DeltaMtot").value || "NaN");

    const betaI = parseFloat(document.getElementById("betaI").value);
    const alpha_c_manual = parseFloat(document.getElementById("alpha_c_manual").value);

    // Armaduras de verifica√ß√£o
    let As_y_pos=0, As_y_neg=0, As_x_pos=0, As_x_neg=0, As_total_circ=0, n_barras_circ=0;
    if (tipoSecao === "ret"){
      As_y_pos = parseFloat(document.getElementById("As_y_pos").value || "0");
      As_y_neg = parseFloat(document.getElementById("As_y_neg").value || "0");
      As_x_pos = parseFloat(document.getElementById("As_x_pos").value || "0");
      As_x_neg = parseFloat(document.getElementById("As_x_neg").value || "0");
    } else {
      As_total_circ = parseFloat(document.getElementById("As_total_circ").value || "0");
      n_barras_circ = parseInt(document.getElementById("n_barras_circ").value || "0");
    }

    // Validar b√°sico
    if(!isFinite(fck) || fck<=0 || !isFinite(fyk_long) || !isFinite(Nsd_kN)){
      saida.innerHTML = "<p><span class='tag tag-err'>Erro</span> Verifique fck, a√ßo e Nsd.</p>";
      return;
    }

    // Propriedades de c√°lculo
    const fcd = 0.85 * fck / gamma_c;          // MPa
    const fyd_long = fyk_long / gamma_s;       // MPa
    const fyd_trans = fyk_trans / gamma_s;     // MPa
    const Eci = 5600 * Math.sqrt(fck);         // MPa (‚âà N/mm¬≤)

    // Geometria e propriedades
    const cob_mm = cob_cm * 10;
    const phi_long_mm = phi_long;
    let Ac_mm2, Ix_mm4, Iy_mm4, b_mm, h_mm, D_mm;
    let descSecao = "";

    if (tipoSecao === "ret"){
      const b_cm = parseFloat(document.getElementById("b").value);
      const h_cm = parseFloat(document.getElementById("h").value);
      if(!isFinite(b_cm) || !isFinite(h_cm) || b_cm<=0 || h_cm<=0){
        saida.innerHTML = "<p><span class='tag tag-err'>Erro</span> Se√ß√£o retangular inv√°lida.</p>";
        return;
      }
      b_mm = b_cm * 10;
      h_mm = h_cm * 10;
      Ac_mm2 = b_mm * h_mm;
      Ix_mm4 = b_mm * Math.pow(h_mm,3) / 12.0; // eixo x (flex√£o no plano yz ‚Üí My)
      Iy_mm4 = h_mm * Math.pow(b_mm,3) / 12.0; // eixo y (flex√£o no plano xz ‚Üí Mx)
      descSecao = `Retangular b = ${fmt(b_cm)} cm, h = ${fmt(h_cm)} cm`;
    } else {
      const D_cm = parseFloat(document.getElementById("D").value);
      if(!isFinite(D_cm) || D_cm<=0){
        saida.innerHTML = "<p><span class='tag tag-err'>Erro</span> Di√¢metro inv√°lido.</p>";
        return;
      }
      D_mm = D_cm * 10;
      Ac_mm2 = Math.PI * Math.pow(D_mm,2)/4.0;
      const I_circ = Math.PI * Math.pow(D_mm,4)/64.0;
      Ix_mm4 = I_circ;
      Iy_mm4 = I_circ;
      descSecao = `Circular D = ${fmt(D_cm)} cm`;
    }

    // Raios de gira√ß√£o
    const i_x_mm = Math.sqrt(Ix_mm4 / Ac_mm2);
    const i_y_mm = Math.sqrt(Iy_mm4 / Ac_mm2);

    const l0x_mm = l0x_m * 1000.0;
    const l0y_mm = l0y_m * 1000.0;
    const lambda_x = l0x_mm / i_x_mm;
    const lambda_y = l0y_mm / i_y_mm;

    // Œ±c autom√°tico se n√£o informado (compress√£o somente)
    let alpha_c;
    if (isFinite(alpha_c_manual)){
      alpha_c = alpha_c_manual;
    } else {
      if (Nsd_kN > 0){
        const Nsd_N = Nsd_kN * 1000.0;
        const Ac_mm2_local = Ac_mm2;
        alpha_c = Nsd_N / (Ac_mm2_local * fcd);  // N / (mm¬≤¬∑MPa) = N / (N/mm¬≤¬∑mm¬≤) = adim.
      } else {
        alpha_c = 0.0;
      }
    }

    // Rigidez secante (bem aproximada)
    const Esec = Eci / (1 + (Nsd_kN>0 ? phi : 0));     // MPa
    const Ex_eff = Esec * betaI;
    const Ey_eff = Esec * betaI;

    // Ncr local em x,y (Euler com rigidez reduzida)
    const Ncrx_kN = (Math.PI*Math.PI * Ex_eff * Ix_mm4) / (Math.pow(l0x_mm,2)) / 1000.0;
    const Ncry_kN = (Math.PI*Math.PI * Ey_eff * Iy_mm4) / (Math.pow(l0y_mm,2)) / 1000.0;

    // Œ≥z global pela NBR se M1tot e ŒîMtot forem informados
    let gamma_z_NBR = NaN, gamma_z_auto = NaN, gamma_z_final = NaN;
    if (isFinite(M1tot_kNm) && isFinite(DeltaMtot_kNm) && M1tot_kNm>0){
      const raz = DeltaMtot_kNm / M1tot_kNm;
      gamma_z_NBR = 1.0 / (1.0 - raz);
    }
    // Œ≥z auto aproximado via N/Ncr(m√©dio)
    const Nsd_abs = Math.abs(Nsd_kN);
    const Ncr_med_kN = (Ncrx_kN + Ncry_kN)/2.0;
    if (Ncr_med_kN>0){
      gamma_z_auto = 1.0 / (1.0 - Nsd_abs / Ncr_med_kN);
    }
    gamma_z_final = isFinite(gamma_z_NBR) ? gamma_z_NBR : gamma_z_auto;

    // Momentos de 1¬™ ordem equivalentes (m√°ximo absoluto entre topo/base)
    const M1x_kNm = Math.max(Math.abs(Msdx_top), Math.abs(Msdx_bot));
    const M1y_kNm = Math.max(Math.abs(Msdy_top), Math.abs(Msdy_bot));

    // Œ±b
    function calcAlphaB(Ma, Mb, tipo){
      let alphaB = 1.0;
      if (tipo === "biapoiado_sem_q"){
        const M1 = Math.abs(Ma);
        const M2 = Math.abs(Mb);
        if (M1>0){
          if (Ma*Mb>=0){
            const psi = Math.min(M2/M1,1.0);
            alphaB = 0.6 + 0.4*psi;
          } else {
            alphaB = 0.4;
          }
        }
        alphaB = Math.max(0.4, Math.min(alphaB,1.0));
      } else if (tipo === "biapoiado_com_q"){
        alphaB = 1.0;
      } else if (tipo === "balanco"){
        // aproximado: Œ±b = 0,8 + 0,2 (Mmid/Meng), 0,85 ‚â§ Œ±b ‚â§ 1,0
        const Meng = Math.abs(Mb); // assume Mb = momento no engaste (base)
        const Mmid = Math.abs(Ma); // assume Ma = momento pr√≥ximo meio
        if (Meng>0){
          const psi = Math.min(Mmid/Meng,1.0);
          alphaB = 0.8 + 0.2*psi;
        } else {
          alphaB = 0.85;
        }
        alphaB = Math.max(0.85, Math.min(alphaB,1.0));
      } else {
        alphaB = 1.0;
      }
      return alphaB;
    }

    // Eccentricidades e Œª1 em cada dire√ß√£o (se Nsd>0)
    let e1x_mm=0, e1y_mm=0, lambda1_x=0, lambda1_y=0;
    if (Nsd_kN>0){
      const Nsd_N = Nsd_kN*1000.0;
      if (M1x_kNm>0) e1x_mm = (M1x_kNm*1e6) / Nsd_N;
      if (M1y_kNm>0) e1y_mm = (M1y_kNm*1e6) / Nsd_N;

      let hdir_x_mm, hdir_y_mm;
      if (tipoSecao === "ret"){
        // eixo x (Mx) ‚Üí flex√£o no plano xz, altura "h" na dire√ß√£o y
        hdir_x_mm = h_mm;
        hdir_y_mm = b_mm;
      } else {
        hdir_x_mm = D_mm;
        hdir_y_mm = D_mm;
      }

      const alphaB_x = calcAlphaB(Msdx_top, Msdx_bot, tipoAlphaB);
      const alphaB_y = calcAlphaB(Msdy_top, Msdy_bot, tipoAlphaB);

      const e_over_h_x = (hdir_x_mm>0) ? (Math.abs(e1x_mm)/hdir_x_mm) : 0;
      const e_over_h_y = (hdir_y_mm>0) ? (Math.abs(e1y_mm)/hdir_y_mm) : 0;

      lambda1_x = calcLambda1(e_over_h_x, alphaB_x);
      lambda1_y = calcLambda1(e_over_h_y, alphaB_y);
    }

    // Momentos de 2¬™ ordem local aproximados (compress√£o)
    let M2x_kNm = M1x_kNm;
    let M2y_kNm = M1y_kNm;
    let info2ord = "";
    if (Nsd_kN>0){
      const use2ord_x = (lambda_x > lambda1_x);
      const use2ord_y = (lambda_y > lambda1_y);
      const gamma_loc_x = 1.0 / (1.0 - Nsd_abs / Ncrx_kN);
      const gamma_loc_y = 1.0 / (1.0 - Nsd_abs / Ncry_kN);
      if (use2ord_x){
        M2x_kNm = M1x_kNm * gamma_loc_x;
        info2ord += `Dire√ß√£o x: Œªx = ${fmt(lambda_x,1)} > Œª1x = ${fmt(lambda1_x,1)} ‚áí considerar 2¬™ ordem (Œ≥_loc,x ‚âà ${fmt(gamma_loc_x,3)}).<br>`;
      } else {
        info2ord += `Dire√ß√£o x: Œªx = ${fmt(lambda_x,1)} ‚â§ Œª1x = ${fmt(lambda1_x,1)} ‚áí 2¬™ ordem local dispensada.<br>`;
      }
      if (use2ord_y){
        M2y_kNm = M1y_kNm * gamma_loc_y;
        info2ord += `Dire√ß√£o y: Œªy = ${fmt(lambda_y,1)} > Œª1y = ${fmt(lambda1_y,1)} ‚áí considerar 2¬™ ordem (Œ≥_loc,y ‚âà ${fmt(gamma_loc_y,3)}).<br>`;
      } else {
        info2ord += `Dire√ß√£o y: Œªy = ${fmt(lambda_y,1)} ‚â§ Œª1y = ${fmt(lambda1_y,1)} ‚áí 2¬™ ordem local dispensada.<br>`;
      }
    } else {
      info2ord = "Elemento tracionado (Nsd &lt;= 0): efeitos de 2¬™ ordem locais s√£o desprez√≠veis.";
    }

    // Fun√ß√£o de √°rea m√≠nima/m√°xima de armadura (NBR ‚Äì vigas/pilares ‚Äì uso b√°sico).
    function rhoMinFlexao(fck){
      const fcks = [20,25,30,35,40,45,50,55,60,65,70,75,80,85,90];
      const rhosPct = [0.150,0.150,0.150,0.164,0.179,0.194,0.208,0.211,0.219,0.226,0.233,0.239,0.245,0.251,0.256];
      if (fck <= fcks[0]) return rhosPct[0]/100.0;
      if (fck >= fcks[fcks.length-1]) return rhosPct[rhosPct.length-1]/100.0;
      for (let i=0;i<fcks.length-1;i++){
        if (fck>=fcks[i] && fck<=fcks[i+1]){
          const t = (fck - fcks[i])/(fcks[i+1]-fcks[i]);
          const rhoPct = rhosPct[i] + t*(rhosPct[i+1]-rhosPct[i]);
          return rhoPct/100.0;
        }
      }
      return 0.0015;
    }
    const rho_min = rhoMinFlexao(fck);
    const As_min_mm2 = rho_min * Ac_mm2;
    const As_max_mm2 = 0.04 * Ac_mm2;  // 4%¬∑Ac

    //-------- Dimensionar As (sugest√£o) usando modelo de viga + N --------//
    let As_sug_mm2 = 0, As_sug_faces = {x_pos:0,x_neg:0,y_pos:0,y_neg:0}, info_dim = "";

    if (modoCalc === "dimensionar"){
      if (Nsd_kN >= 0){
        // compress√£o: N principal no concreto, As dimensionada pelos momentos de 2¬™ ordem
        // Use "viga equivalente" em cada dire√ß√£o, pega maior taxa.
        function AsPorMomento(M_kNm, d_mm){
          if (M_kNm<=0) return 0;
          const M_Nmm = M_kNm * 1e6;
          // aproxima√ß√£o: z ‚âà 0,9d
          const z_mm = 0.9*d_mm;
          return M_Nmm / (fyd_long * z_mm);
        }
        // Profundidade √∫til em x,y (ret / circ)
        let d_x_mm, d_y_mm;
        if (tipoSecao === "ret"){
          d_x_mm = h_mm - cob_mm - phi_long_mm/2.0; // flex√£o em torno de x ‚áí tra√ß√£o em borda y
          d_y_mm = b_mm - cob_mm - phi_long_mm/2.0; // flex√£o em torno de y ‚áí tra√ß√£o em borda x
        } else {
          const D = D_mm;
          // simplifica√ß√£o: profundidade √∫til ‚âà 0,9D/2
          d_x_mm = 0.9*D/2;
          d_y_mm = d_x_mm;
        }
        const As_Mx = AsPorMomento(M2x_kNm, d_x_mm);
        const As_My = AsPorMomento(M2y_kNm, d_y_mm);

        // Combina√ß√µes N+M: se Nsd muito alto, aumenta seguran√ßa via taxa m√≠nima elevada.
        const fator_N = Math.min(Math.max(Nsd_kN / (0.5*fcd*Ac_mm2/1000.0), 0), 2); // bem aproximado
        const As_base = Math.max(As_Mx, As_My);
        let As_total_est = As_base * (1 + 0.3*fator_N);
        As_total_est = Math.max(As_total_est, As_min_mm2);
        As_total_est = Math.min(As_total_est, As_max_mm2*0.9);

        As_sug_mm2 = As_total_est;
        // Distribui√ß√£o sim√©trica: 4 faces iguais, exceto circular ‚Üí per√≠metro.
        if (tipoSecao === "ret"){
          const As_face = As_total_est/4.0;
          As_sug_faces = {x_pos:As_face, x_neg:As_face, y_pos:As_face, y_neg:As_face};
          info_dim =
            `Compress√£o normal preponderantemente suportada pelo concreto (Nrd ‚âà 0,85¬∑fcd¬∑Ac). `+
            `Armadura sugerida √© sim√©trica nas 4 faces e dimensionada pelos momentos de 2¬™ ordem (x e y) `+
            `com pequena majora√ß√£o em fun√ß√£o de Nsd.`;
        } else {
          const As_barra = As_total_est / Math.max(n_barras_circ||8,1);
          info_dim =
            `Se√ß√£o circular: armadura sugerida distribu√≠da em ${n_barras_circ||8} barras `+
            `de aproximadamente ${fmt(As_barra,1)} mm¬≤ cada (ex.: √ò${fmt(Math.sqrt(4*As_barra/Math.PI),1)} mm).`;
        }
      } else {
        // tra√ß√£o + flex√£o: todo esfor√ßo em As (concreto ignorado)
        const N_ten_kN = Math.abs(Nsd_kN);
        const N_ten_N = N_ten_kN*1000.0;
        const As_N = N_ten_N / fyd_long;
        // momento m√°ximo resultante (combina x e y como norma)
        const Mres_kNm = Math.sqrt(M2x_kNm*M2x_kNm + M2y_kNm*M2y_kNm);
        let d_mm_equiv;
        if (tipoSecao === "ret"){
          const d1 = h_mm - cob_mm - phi_long_mm/2.0;
          const d2 = b_mm - cob_mm - phi_long_mm/2.0;
          d_mm_equiv = Math.min(d1,d2);
        } else {
          d_mm_equiv = 0.9*(D_mm/2);
        }
        const M_Nmm = Mres_kNm*1e6;
        const z_mm = 0.9*d_mm_equiv;
        const As_M = (M_Nmm>0) ? (M_Nmm/(fyd_long*z_mm)) : 0;
        let As_total_est = As_N + As_M;
        As_total_est = Math.max(As_total_est, As_min_mm2);
        As_total_est = Math.min(As_total_est, As_max_mm2*0.9);
        As_sug_mm2 = As_total_est;
        if (tipoSecao === "ret"){
          const As_face = As_total_est/4.0;
          As_sug_faces = {x_pos:As_face, x_neg:As_face, y_pos:As_face, y_neg:As_face};
          info_dim =
            `Elemento tracionado: concreto ignorado √† tra√ß√£o. `+
            `As sugerida considera Nsd em tra√ß√£o e flex√£o composta (resultante de Mx,My), `+
            `distribu√≠da simetricamente nas quatro faces.`;
        } else {
          const As_barra = As_total_est / Math.max(n_barras_circ||8,1);
          info_dim =
            `Se√ß√£o circular tracionada: As,total sugerida = ${fmt(As_total_est,1)} mm¬≤ `+
            `em cerca de ${n_barras_circ||8} barras (‚âà${fmt(As_barra,1)} mm¬≤ cada).`;
        }
      }
    }

    //---------- Somente verifica√ß√£o: capacidades aproximadas ----------//
    let info_verif = "";
    if (modoCalc === "verificar"){
      if (tipoSecao === "ret"){
        // Somar As por dire√ß√£o
        const As_total_long = As_x_pos+As_x_neg+As_y_pos+As_y_neg;
        const As_total_eff = As_total_long;
        // Check min/max
        let tagAs = "";
        if (As_total_eff < As_min_mm2){
          tagAs = "<span class='tag tag-err'>As &lt; As,min (pilar)</span>";
        } else if (As_total_eff > As_max_mm2){
          tagAs = "<span class='tag tag-err'>As &gt; 4%¬∑Ac (NBR)</span>";
        } else {
          tagAs = "<span class='tag tag-ok'>Taxa de armadura entre m√≠nima e m√°xima</span>";
        }

        // Capacidade axial pura (bem simplificada)
        const Nrd_conc_kN = 0.85 * fcd * Ac_mm2 / 1000.0;
        const Nrd_aco_kN = As_total_eff * fyd_long / 1000.0;
        const Nrd_kN = Nrd_conc_kN + Nrd_aco_kN;
        const FSN = (Nsd_kN>0) ? (Nrd_kN / Nsd_kN) : Infinity;

        // Flex√£o em x,y usando viga equivalente (As em bordas relevantes)
        function Mrd_viga(b_mm_loc, h_mm_loc, As_sup_mm2, As_inf_mm2, M2_kNm){
          if (M2_kNm<=0) return {Mrd_kNm:0, FS:Infinity};
          const d_mm_loc = h_mm_loc - cob_mm - phi_long_mm/2.0;
          const dLinha_mm = cob_mm + phi_long_mm/2.0;
          const M_Nmm = M2_kNm*1e6;
          // aprox: armadura simples, concreto comprimido, a√ßo tracionado
          // resolver neutro x por itera√ß√£o, mas aqui aproximamos com viga simples
          const z_mm = 0.9*d_mm_loc;
          const As_trac = Math.max(As_sup_mm2, As_inf_mm2);
          const Mrd_Nmm = As_trac * fyd_long * z_mm;
          const Mrd_kNm_loc = Mrd_Nmm/1e6;
          return {Mrd_kNm:Mrd_kNm_loc, FS: Mrd_kNm_loc/M2_kNm};
        }
        const mx = Mrd_viga(b_mm, h_mm, As_y_pos, As_y_neg, M2x_kNm);
        const my = Mrd_viga(h_mm, b_mm, As_x_pos, As_x_neg, M2y_kNm);

        info_verif += `${tagAs}<br>`;
        info_verif += `Nrd ‚âà ${fmt(Nrd_kN,1)} kN ‚áí FS<sub>N</sub> ‚âà ${fmt(FSN,2)}.<br>`;
        info_verif += `Flex√£o x (Msd,x,2ord ‚âà ${fmt(M2x_kNm,1)} kN¬∑m): Mrd,x ‚âà ${fmt(mx.Mrd_kNm,1)} kN¬∑m ‚áí FS<sub>x</sub> ‚âà ${fmt(mx.FS,2)}.<br>`;
        info_verif += `Flex√£o y (Msd,y,2ord ‚âà ${fmt(M2y_kNm,1)} kN¬∑m): Mrd,y ‚âà ${fmt(my.Mrd_kNm,1)} kN¬∑m ‚áí FS<sub>y</sub> ‚âà ${fmt(my.FS,2)}.`;
      } else {
        // circular ‚Äì usa As_total_circ
        const As_total_eff = As_total_circ;
        let tagAs = "";
        if (As_total_eff < As_min_mm2){
          tagAs = "<span class='tag tag-err'>As &lt; As,min (pilar)</span>";
        } else if (As_total_eff > As_max_mm2){
          tagAs = "<span class='tag tag-err'>As &gt; 4%¬∑Ac (NBR)</span>";
        } else {
          tagAs = "<span class='tag tag-ok'>Taxa de armadura entre m√≠nima e m√°xima</span>";
        }
        const Nrd_conc_kN = 0.85 * fcd * Ac_mm2 / 1000.0;
        const Nrd_aco_kN = As_total_eff * fyd_long / 1000.0;
        const Nrd_kN = Nrd_conc_kN + Nrd_aco_kN;
        const FSN = (Nsd_kN>0) ? (Nrd_kN / Nsd_kN) : Infinity;

        // momento resistente aproximado (distribui√ß√£o uniforme de barras)
        const D = D_mm;
        const d_mm = 0.9*(D/2);
        const M2res_kNm = Math.sqrt(M2x_kNm*M2x_kNm + M2y_kNm*M2y_kNm);
        const M_Nmm = M2res_kNm*1e6;
        const z_mm = 0.9*d_mm;
        const Mrd_Nmm = As_total_eff * fyd_long * z_mm;
        const Mrd_kNm = Mrd_Nmm/1e6;
        const FS_M = (M2res_kNm>0) ? (Mrd_kNm/M2res_kNm) : Infinity;

        info_verif += `${tagAs}<br>`;
        info_verif += `Nrd ‚âà ${fmt(Nrd_kN,1)} kN ‚áí FS<sub>N</sub> ‚âà ${fmt(FSN,2)}.<br>`;
        info_verif += `Mrd,eq (flex√£o obl√≠qua) ‚âà ${fmt(Mrd_kNm,1)} kN¬∑m ‚áí FS<sub>M</sub> ‚âà ${fmt(FS_M,2)} para Msd,eq ‚âà ${fmt(M2res_kNm,1)} kN¬∑m.`;
      }
    }

    // ---------- Montar sa√≠da HTML ---------- //
    let tagComp = "";
    if (Nsd_kN>0){
      tagComp = "<span class='tag tag-ok'>Compress√£o (Nsd &gt; 0)</span>";
    } else if (Nsd_kN<0){
      tagComp = "<span class='tag tag-warn'>Tra√ß√£o (Nsd &lt; 0)</span>";
    } else {
      tagComp = "<span class='tag tag-warn'>Nsd = 0 (flex√£o pura)</span>";
    }

    let tagQuadro = "";
    if (isFinite(gamma_z_final)){
      if (gamma_z_final <= 1.1){
        tagQuadro = "<span class='tag tag-ok'>Œ≥z ‚â≤ 1,10 ‚áí estrutura ‚âà n√≥s fixos</span>";
      } else {
        tagQuadro = "<span class='tag tag-warn'>Œ≥z &gt; 1,10 ‚áí estrutura de n√≥s m√≥veis (2¬™ ordem global relevante)</span>";
      }
    } else {
      tagQuadro = "<span class='tag tag-warn'>Œ≥z n√£o informado (p√≥rtico n√£o analisado)</span>";
    }

    let html = "";
    html += `<p><b>Pilar ${idPilar}</b> ‚Äì ${descSecao}<br>`;
    if (obra) html += `Obra: <b>${obra}</b><br>`;
    html += `Engenheiro: <b>${engenheiro}</b></p>`;

    html += `<p><b>Materiais:</b><br>
      fck = ${fmt(fck,0)} MPa ‚áí fcd ‚âà ${fmt(fcd,2)} MPa;<br>
      fyk,long = ${fmt(fyk_long,0)} MPa ‚áí fyd ‚âà ${fmt(fyd_long,2)} MPa;<br>
      Eci ‚âà ${fmt(Eci,0)} MPa; œÜ = ${fmt(phi,2)}; Œ≤ = ${fmt(betaI,2)}; Œ±c ‚âà ${fmt(alpha_c,2)}.
    </p>`;

    html += `<p><b>Se√ß√£o / rigidez:</b><br>
      Ac ‚âà ${fmt(Ac_mm2/100,2)} cm¬≤;<br>
      Ix ‚âà ${fmt(Ix_mm4/1e4,2)} cm‚Å¥; Iy ‚âà ${fmt(Iy_mm4/1e4,2)} cm‚Å¥;<br>
      i<sub>x</sub> ‚âà ${fmt(i_x_mm/10,2)} cm; i<sub>y</sub> ‚âà ${fmt(i_y_mm/10,2)} cm.<br>
      ‚Ñì<sub>0x</sub> = ${fmt(l0x_m,2)} m ‚áí Œªx ‚âà ${fmt(lambda_x,1)};<br>
      ‚Ñì<sub>0y</sub> = ${fmt(l0y_m,2)} m ‚áí Œªy ‚âà ${fmt(lambda_y,1)}.
    </p>`;

    html += `<p><b>Esfor√ßos ELU:</b> ${tagComp}<br>
      Nsd = ${fmt(Nsd_kN,1)} kN;<br>
      Msd,x (topo/base) = ${fmt(Msdx_top,1)} / ${fmt(Msdx_bot,1)} kN¬∑m;<br>
      Msd,y (topo/base) = ${fmt(Msdy_top,1)} / ${fmt(Msdy_bot,1)} kN¬∑m.
    </p>`;

    if (Nsd_kN>0){
      html += `<p><b>Excentricidades de 1¬™ ordem:</b><br>
        e1x ‚âà ${fmt(e1x_mm/10,2)} cm; e1y ‚âà ${fmt(e1y_mm/10,2)} cm.<br>
        Œª1x ‚âà ${fmt(lambda1_x,1)}; Œª1y ‚âà ${fmt(lambda1_y,1)} (NBR 6118 / Bastos). :contentReference[oaicite:9]{index=9}
      </p>`;
    }

    html += `<p><b>2¬™ ordem local (pilar isolado):</b><br>
      ${info2ord}
    </p>`;

    html += `<p><b>Œ≥<sub>z</sub> global:</b><br>`;
    if (isFinite(gamma_z_NBR)){
      html += `Œ≥z (NBR ‚Äì ŒîM/M1) ‚âà ${fmt(gamma_z_NBR,3)};<br>`;
    }
    if (isFinite(gamma_z_auto)){
      html += `Œ≥z,auto (Euler com Ncr m√©dio) ‚âà ${fmt(gamma_z_auto,3)};<br>`;
    }
    html += `${tagQuadro}</p>`;

    html += `<p><b>Taxas de armadura (limites normativos):</b><br>
      œÅm√≠n ‚âà ${fmt(rho_min*100,3)} % ‚áí As,m√≠n ‚âà ${fmt(As_min_mm2,1)} mm¬≤;<br>
      œÅm√°x = 4% ‚áí As,m√°x = ${fmt(As_max_mm2,1)} mm¬≤.
    </p>`;

    if (modoCalc === "dimensionar"){
      html += `<hr><p class="section-title">Dimensionamento autom√°tico (sugest√£o aproximada)</p>`;
      html += `<p>As,total sugerida ‚âà <b>${fmt(As_sug_mm2,1)} mm¬≤</b> ‚âà ${fmt(As_sug_mm2/100,2)} cm¬≤.</p>`;
      if (tipoSecao === "ret"){
        html += `<ul>
          <li>Faces +y / ‚àíy: As ‚âà ${fmt(As_sug_faces.y_pos,1)} mm¬≤ cada</li>
          <li>Faces +x / ‚àíx: As ‚âà ${fmt(As_sug_faces.x_pos,1)} mm¬≤ cada</li>
        </ul>`;
      }
      html += `<p class="small">${info_dim}<br>
        <b>Alerta:</b> dimensionamento ainda simplificado (N majoritariamente no concreto, flex√£o tratada como viga equivalente).
        Para pilares muito esbeltos / flex√£o obl√≠qua forte, confira em software especializado.
      </p>`;
    } else {
      html += `<hr><p class="section-title">Verifica√ß√£o com As informada</p>`;
      html += `<p>${info_verif}</p>`;
      html += `<p class="small">
        Verifica√ß√£o aproximada: modelo de viga em cada dire√ß√£o + capacidade axial concreta + a√ßo.
        Para checagem fina N‚ÄìMx‚ÄìMy com 2¬™ ordem n√£o linear, utilize diagrama interativo ou m√©todo do pilar-padr√£o completo (fora do escopo deste c√≥digo).
      </p>`;
    }

    saida.innerHTML = html;

  } catch (err){
    console.error(err);
    saida.innerHTML = "<p><span class='tag tag-err'>Erro inesperado</span> ‚Äì verifique os dados de entrada.</p>";
  }
}
</script>
</body>
</html>

